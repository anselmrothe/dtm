UC Merced
Proceedings of the Annual Meeting of the Cognitive Science
Society
Title
Mental simulation and the construction of informal algorithms
Permalink
https://escholarship.org/uc/item/16m4t0hj
Journal
Proceedings of the Annual Meeting of the Cognitive Science Society, 35(35)
Authors
Khemlani, Sangeet
Johnson-Laird, Phil
Publication Date
2013-01-01
Peer reviewed
  eScholarship.org                                 Powered by the California Digital Library
                                                                    University of California

                   Mental simulation and the construction of informal algorithms
                                                 Sangeet Khemlani1 and Phil Johnson-Laird2
                                           sunny.khemlani.ctr@nrl.navy.mil, phil@princeton.edu
                                        1
                                          Naval Research Laboratory, Washington, DC 20375 USA
                                              2
                                                Princeton University, Princeton NJ 08540 USA
                               Abstract                                      Expert programming depends on more than just mental
   We describe two studies that show that when individuals who
                                                                          simulation, however. Programmers often have specialized
   are not programmers create algorithms, they rely on mental             knowledge of programming languages, of relevant software
   simulations. Our studies concerned a railway domain in which           platforms and tools, and about computer science in general
   carriages are rearranged – a simple environment but                    (Boehm-Davis & Ross, 1992). For that reason, many studies
   equivalent in computational power to a Turing machine.                 have tested the ability of novice programmers to write
   Participants successfully solved rearrangement problems                computer programs (see, e.g., Anderson, Pirolli, & Farrell,
   (Experiment 1), and created algorithms to solve them                   1988). Few have investigated how those without any
   (Experiment 2) and their performance corroborated the use of
   simulation. The participants tended to use loops and to prefer         background in programming try to create algorithms. Miller
   while-loops even though they are of greater computational              (1974) pioneered such studies. He examined the way college
   power than for-loops. Their ability to create algorithms for           students unfamiliar with computers wrote instructions for
   abstract problems improved when they first had to create               others to follow, and found that they tended not to use loops
   algorithms for more concrete problems. We devised a                    in their instructions, even though they could understand
   computer program that creates its own algorithms for                   them (Miller, 1981). More recently, Pane and his colleagues
   rearrangement problems. It generates Lisp functions that
                                                                          carried out a study in which they presented non-
   operate on lists and creates descriptions of them in everyday
   language. The complexity of the resulting algorithms predicts          programmers with static descriptions of an agent moving in
   participants’ difficulty in devising them.                             a popular video game, PacMan, and the participants had to
                                                                          summarize how agents moved in general. They again
   Keywords: algorithms, computer programming, creativity,                preferred not to make use of loops, but when they did, they
   deduction, problem-solving, reasoning                                  appeared to rely on while-loops (Pane et al., 2001).
                                                                             Despite these results, there exists no psychological theory
                           Introduction                                   of how non-programmers construct algorithms. To develop
   A long controversy about human thinking is whether it                  such a theory, and to study algorithmic creativity in non-
depends on logic (Rips, 1994), probabilities (Oakford &                   programmers, we designed a novel problem-solving task
Chater, 2007; Tenenbaum & Griffiths, 2001), or mental                     environment in which reasoners have to sort the order of a
simulations (Craik, 1943; Johnson-Laird, 1983; Hegarty,                   list in various ways. We introduce the environment below,
2004). Many inferences such as syllogistic deductions can                 and then explain how individuals build kinematic mental
be explained by mechanisms that depend on any of the three                models to construct algorithms for their solutions. We then
approaches (see Khemlani & Johnson-Laird, 2012, for a                     describe two experiments that show that reasoners
review). Indeed, few inferential tasks unequivocally depend               intuitively understand the environment (Experiment 1) and
on one approach. Computer programming may be such a                       that they can mentally create algorithms for the problems in
task: it is readily explained by appealing to mental                      the environment (Experiment 2).
simulation (Bornat, Dehnadi, & Simon, 2008; Caspersen,
Bennedsen, & Larsen, 2007; Kurland & Pea, 1985). To                                      Rearrangement problems
debug faulty code, programmers have to mentally simulate                                and the railway environment
the algorithm to discover the situations in which the
                                                                             We studied how individuals who have never learned
computer failed to produce the expected output. It is less
                                                                          computer programming create algorithms in everyday
apparent how mental rules of logic or probabilities could be
                                                                          language. For problems that they readily understood, we
used develop algorithms. Logic can be used to deduce the
                                                                          used the railway environment shown in Figure 1. The
consequences of a program, but the creation of a program
                                                                          environment consists of a railway track and a siding. It is an
goes beyond logic (cf. Gulwani, 2010; Kitzelmann,
                                                                          analog of a finite-state device with two stacks – the left
Schmidt, Mühlpfordt, & Wysotzki, 2002). Probabilities
                                                                          track (a) holds the input and also acts as a stack, the siding
hardly enter into the process, because computer programs
                                                                          (b) acts as another stack, and the right track (c) holds the
are deterministic, and the language of the probability
                                                                          final output. Participants’ task is to move the cars from the
calculus is ill equipped to operate over the structures of
                                                                          left track to the right track into a specific order. Cars can
programs. Mental simulation is therefore an appropriate
                                                                          move only from the siding to and from the left track, and
framework with which to characterize the ability to create
                                                                          from left track to right track. Multiple cars can be moved at
algorithms, and researchers can benefit from studying the
                                                                          once, i.e., any move of a selected car applies to all cars in
simulations programmers use to solve tasks (Holt, Boehm-
                                                                          front of it. For example, in Figure 1, if you moved the E car
Davis, & Schultz, 1987).
                                                                     2698

                                                                          A model-based theory of algorithmic creativity
                                                                            How do naïve individuals create informal algorithms? We
         a.                                           c.
                                                                         hypothesize that individuals simulate solutions to problems,
                                                                         where a simulation consists of a sequence of kinematic
                                                                         mental models representing states of the world, real or
                                            b.                           imaginary, and the sequence itself represents a logical or
                                                                         temporal order of the states (Johnson-Laird, 1983, Ch. 15).
Figure 1. The railway domain with an example of an initial
configuration in which a set of cars is on the left side (a) of the
                                                                         Reasoners use such simulations to carry out three separate
track, the siding (b) can hold one or more cars while other cars are     steps to create an algorithm: 1) they solve at least two
moved to the right side of the track (c).                                different instances of a rearrangement problem using a
                                                                         kinematic sequence of moves; 2) they scan the kinematic
                                                                         sequences to abduce a pattern; 3) they translate the pattern
to the right track, then the F car would move along in front             into a verbal description. We address the three steps in turn.
of it. To restrict the environment to a single stack, cars could
move from the siding only to the output on the right track.              Step 1: Problem-solving as simulation. The first step is to
In summary, only three sorts of move are possible in the                 solve two different instances of a rearrangement problem.
railway environment:                                                     Otherwise, re-arrangements are ambiguous. At any point in
                                                                         the simulation, only a single move is made, and so to
    R: one or more cars moved from left track to right track.            reverse, say, four carriages, reasoners can begin by
    S: one or more cars moved from left track to siding.                 envisaging the transformation from the start state:
    L: one or more cars moved from the siding to left track.
                                                                                      ABCDEF[ ] → [ ] . . . A
One constraint is that cars can be neither removed nor added
to trains in our rearrangement problems – if they could be,              This partial goal calls for a move of five cars onto the
then the railway environment would be equivalent to a                    siding, A[BCDEF], so A can be moved to right track,
universal Turing machine power.                                          [BCDEF]A. The next partial goal is to get B to right track,
   Experiment 1 below investigated all 24 possible re-                   and so it should be moved to left track, B[CDEF]A, and
arrangements of four cars, and examined whether the                      over to right track, [CDEF]BA. A repeated loop of these
participants perseverated, i.e., made one or more                        two operations moves each car in turn off the siding and to
unnecessary moves. They can use a simple variant of                      right track, and solves the problem.
“means-ends” analysis in which they work backwards from                     Two variables should affect performance in the solution
the required goal, invoking operations relevant to reducing              of rearrangement problems: the number of moves and the
the difference between the current state and the goal (e.g.,             number of their operands. Obviously, the greater the number
Newell & Simon, 1972; Newell, 1990). For rearrangement                   of moves, the more difficult a problem should be – the only
problems, they need only envisage each successive car in                 sort of theory that would not make this prediction would be
the goal. Suppose, for instance, they have to re-arrange the             one that made no appeal to simulation. A more subtle
order ABCD into ACBD. The starting state is: ABCD[ ],                    prediction concerns the number of operands. In a reversal
where the square brackets denote the contents of the siding,             problem, such as the one above, each move after the first
which is empty at the start. Their immediate goal is to get D            has an operand of one car. We can contrast this case with
to the far end of the right track: [ ] . . . D. So, they move D          the solution of a palindrome problem, such as:
from left to right track: ABC[ ]D. The next partial goal is to
get B to the right track, and so they need to move C out of                           ABCCBA[ ] → [ ]AABBCC
the way onto the siding: AB[C]D. Now, they can move B to
the right: A[C]BD. They move C off the stack: AC[ ]BD.                   There are three cars, BCC, on the left that match the goal,
The next move is intriguing. They should move both A and                 but they are blocked, and so to solve the problem, the
C together from left to right track. But, if reasoners                   blocking cars are moved onto the siding: ABCC[BA]. The
perseverate, they may move only C to the right track. Their              three cars on the left are moved to the right: A[BA]BCC.
solution won’t be minimal, because they then have to make                One car on the siding matches the goal, and so it is moved
a separate move of A to right track.                                     to the left: AB[A]BCC. Two cars on the left match the goal,
   We investigated how reasoners solve single instances of               and so they are moved to the right: [A]ABBCC. The car on
such problems, but our primary goal was to understand the                the stack matches the goal, and so it is moved to the left and
processes and representations non-programmers use to                     then over to the right, and the problem is solved. Its minimal
create algorithms. In the following section, we explain how              solution required a total of 10 cars to be moved in 6 moves.
kinematic mental models can be used to construct                         This solution has a mean number of operands per move
algorithms, and illustrate the predictions that the model-               greater than that for the reversal problems, and so the theory
based theory makes.                                                      predicts that the palindrome problems should be more
                                                                         difficult than reversal problems of the same number of
                                                                     2699

moves. And individuals may make an unnecessary move in              outputs a for-loop, a while-loop, and a translation of the
their solution of the problem, i.e., they may fail to solve the     while-loop into informal English (see Appendix). Each of
problem parsimoniously. Number of operands has a family             these algorithms solves any instance of the relevant class of
resemblance to “relational complexity”, which concerns the          rearrangements.
number of arguments in a relation, and which affects                  Experiment 1 tested whether solutions to rearrangements
problem difficulty (Halford, Wilson, & Phillips, 1998).             depend on the number of moves and the number of
However, the number of operands concerns, not the number            operands. Experiment 2 tested whether reasoners use
of arguments of an operator, but whether the value of a             simulation to construct algorithms, and therefore formulate
single argument is one or more entities.                            while loops, and whether the theory predicts the relative
                                                                    difficulty of different sorts of problem.
Step 2: Pattern abstraction and abduction. The second step
in creating an algorithm is to recover the structure of the                                 Experiment 1
solutions – the loop they contain, and any operations before          Experiment 1 tested the effects of number of moves and
or after it. Consider the moves to reverse trains of four and       number of operands on the solution of simple rearrangement
five cars, respectively:                                            problems in the railway environment. The problems were
                                                                    simple and called for the rearrangement of only four cars.
             (S3 R1 L1 R1 L1 R1 L1 R1)                              Hence, our interest was in whether the participants could
             (S4 R1 L1 R1 L1 R1 L1 R1 L1 R1)                        solve the problems without making redundant moves. The
                                                                    participants had to solve all the 24 possible rearrangements
where ‘S3’ means move three cars from left track to the             of trains containing four cars. Their minimal solutions call
Siding, ‘R1’ means move one car from left track to Right            for various numbers of moves (1, 4, 5, 6, 7, or 8), and as a
track, and ‘L1’ means move one car from the siding to Left          consequence the theory predicts an increasing trend in
track. The loop of operations is (R1 L1). But, how many             redundant moves for these problems. The total numbers of
times should it be iterated? There are two ways to find the         operands in minimal solutions was (4, 6, 8, 10, or 12), and
answer. The simpler is to observe the conditions in the             as a consequence there should be an increasing trend in
simulation when the loop ceases, respectively:                      redundant moves. Because these two variables are only
                                                                    partially correlated, we were able to examine their effects
            D[ ]CBA                                                 independently (see Table 1 below).
            E[ ]DCBA
                                                                    Method
In both cases, the siding is empty, and so this condition
determines that a while-loop should continue until the siding       Participants. Twenty undergraduate students at Princeton
is empty. The alternative answer depends on computing the           University served as participants, and none had had any
number of times that a for-loop should be executed, and it          prior training in logic or computer science.
calls for the solution of a pair of simultaneous linear
equations to obtain the values of a and b in:                       Design and procedure. Participants acted as their own
                                                                    controls and carried out all 24 problems, which were
          number-of-iterations = a * train-length + b.              presented in a different random order to each of them. When
                                                                    they had completed the experiment, they carried out two of
Step 3: Conversion to natural language. The third and final         the problems again, but they had to think aloud as they did
step is to map the structure of the solution into a description.    so. They were tested individually, and carried out the
A general algorithm for reversing the order of cars applies         experiment on a PC running LispWorks 4.4. They interacted
to trains of any length. Hence, it needs to describe a loop of      with the system using the mouse and the keyboard of the
moves. When reasoners convert the algorithm to a natural            computer. They were shown a three-minute instructional
language description, their responses should yield the              video that guided them through the elements of the railway
condition in which the loop stops (an indication that they’ve       environment, and that presented the instructions. The key
constructed while-loop) or else reflect the number of times         instruction stated that they should try to solve each problem
for which the loop should be executed (an indication that           with as few moves as possible.
they’ve constructed a for-loop). The solution of
simultaneous equations calls for more than just simulation,         Results and discussion
whereas the halting conditions of a loop can be observed in           Non-programmers were able to solve rearrangement
a simulation, and so the theory predicts that correct               problems with ease: they produced very few incorrect
responses should tend to use while-loops more often than            solutions. Table 1 presents the participants’ mean numbers
for-loops.                                                          of moves to solve the problems depending on the minimum
   We have implemented all three steps in a computer                number of moves and the total number of operands. We
program that discovers and outputs algorithms to solve any          dropped the two extreme problems from the statistical
re-arrangement problem that depends on a single loop. It
                                                                2700

                     Total number of operands                          length problems in which trains of eight cars had to be
# of moves in   (cars) moved in minimal solutions                      rearranged, and indefinite-length problems in which trains
a minimal                                            Mean # of         of any number of cars had to be rearranged. The fixed-
                  4       6      8     10     12
solution                                            actual moves       length problems should be easier than indefinite-length
1                1.0                                     1.0           problems, because only the former can be solved without
4                        4.3    4.7    4.6               4.5
5                        5.5    5.2                      5.4           loops. Likewise, complexity and number of operands predict
6                               6.5    6.6               6.6           a trend in difficulty over the three sorts of general
7                               7.9                      7.9           rearrangements: reversals should be easier than
8                               8.3    8.5    8.6        8.4           palindromes, which in turn should be easier than parity
Mean # of                                                              sorts. The latter should be the hardest to solve because they
                 1.0     4.9    6.5    6.9    8.6
actual moves
                                                                       call for an extra operation in their algorithm (see the
Table 1. The mean numbers of moves in Experiment 1 in                  Appendix).
rearrangement problems as a function of the total number of moves
in their minimal solutions and the total number of operands (cars)     Method
to be moved.
                                                                       Design and materials. The participants acted as their own
analysis so that they would not bias the results, i.e., the            controls and carried out six problems: the three sorts of
problem that required only one move to solution, and the               rearrangement as both fixed-length problems of eight cars
problem that had a total of 12 operands. Given that the                and indefinite-length problems of any number of cars. The
participants solved the problems, it is hardly surprising that         session began with five practice problems akin to those in
the mean number of the participants’ moves increased with              Experiment 1, which the participants merely had to solve by
the minimal number of moves required to solve a problem                interacting with the railway system. These problems were
(Page’s trend test, L = 1809.5, z = 8.47, p < .0001). But, the         unrelated to the experimental problems: each of them had a
results also showed that their mean number of moves also               train of 6 cars, and a solution depending on 8 moves. The
increased with the number of operands (Page’s trend test, L            experiment proper followed, and the participants’ task was
= 276, z = 5.69, p < .0001). In other words, the participants          to type out a procedure that would solve each problem, but
tended to fail to find minimal solutions, and as the mean              they were not allowed to interact with the railway
number of operands increased so the number of their moves              environment. They carried out two blocks of trials, one of
increased, independently of the total number of moves in a             the definite problems and one of the indefinite problems,
minimal solution. (For brevity, we spare readers the latency           presented in a counterbalanced order to two groups of
results, but their patterns corroborated both of these effects.)       participants. The order of the three sorts of rearrangement
There was a reliable tendency for the participants to make             was randomized for each participant within the blocks. For
redundant moves. Every participant made at least one                   the indefinite-length problems, the participants were told
redundant move (Binomial, p = .520).                                   that a car containing an ellipsis stood in place for any
   In summary, the experiment shows that naive individuals             number of cars that had the same pattern.
can solve simple rearrangements. It corroborated the
prediction that the number of moves affected the difficulty            Participants and procedure. Twenty students from the same
of the problem, and thereby supported simulation-based                 population as before took part in the experiment. They
accounts. Likewise, it corroborated the prediction unique to           watched an instructional video and were told how to
the model-based theory that the number of operands should              interpret the car containing an ellipsis. They then solved the
affect the difficulty of a problem. The following experiment           practice problems using the same procedure as before. In the
tested whether non-programmers could formulate general                 experiment proper, the participants were told to write a
solutions for rearrangement problems.                                  description of a procedure for solving each of the
                                                                       experimental problems as efficiently as possible. They were
                        Experiment 2                                   free to use their own words in any way that they wanted, but
                                                                       they no longer were allowed to manipulate the cars in the
   In Experiment 2, the participants had to formulate
                                                                       railway environment.
algorithms to solve three sorts of rearrangement: reversals,
such as ABCDEFGH becomes HGFEDCBA; palindromes,
such as ABCDDCBA becomes AABBCCDD; and parity
                                                                       Results and discussion
sorts, such as ABCDEFGH becomes ACEGBDFH.                              Two independent raters scored the correctness of the
Participants had to construct the algorithms in their mind’s           algorithms and whether they contained a while-loop, a for
eye with no access to the railway environment. They were               loop, or no loop whatsoever (see Appendix for examples of
familiar with the environment, because they had just solved            correct responses). Inter-rater reliability was high for
five practice problems on it, but these problems were simple           judgments of correctness (Cohen’s κ = .82) and the sorts of
rearrangements that differed from the problems in the                  loops that participants devised (κ = .73). A third
experiment proper. They were then shown the inputs and                 independent rater resolved the disagreements. Performance
outputs for each of the problems, and they had to write                with the fixed-length problems was at ceiling (90% correct)
down algorithms for solving them. They did so for fixed-
                                                                   2701

                                  a.                                                                b.
                                                                                                                             notice that there is a loop of two operations (move one car
                   Indefinite first   Indefinite last                                Indefinite first   Indefinite last
                                                                                                                             to the right, and then one car onto the siding) that has to be
            1.00
                                                        Response time (in s)
                                                                               400                                           repeated while more than two cars remain on the left track.
            0.75                                                                                                             It follows that while-loops should occur more often than
% Correct
                                                                               300
                                                                                                                             for-loops in putative algorithms, because it is easier to
            0.50                                                                                                             envisage halting conditions for while-loops from
                                                                               200
            0.25
                                                                                                                             simulations than to use them to compute the number of
                                                                               100
                                                                                                                             iterations for a for-loop. The difficulty of the task also
            0.00                                                                 0                                           depends on the Kolmogorov complexity of the program, as
                    l
                 rsa m so
                         e rt      l   e
                                rsa m so
                                         rt                                                l
                                                                                     rsa m so
                                                                                                e rt      l  e
                                                                                                       rsa m so
                                                                                                                rt           indexed in the number of its instructions (in Lisp or in
               ve dro ity     ve dro ity                                           ve dro ity        ve dro ity
             Re alin Par
               P
                           Re alin Par
                              P
                                                                                R e a l i n Pa r
                                                                                   P
                                                                                                  Re alin Par
                                                                                                     P
                                                                                                                             everyday language), and on the number of operands
                                                                                                                             (Experiment 2).
                                                                                                                                Computer scientists often complain about the lack of any
       Figure 2. The percentages of correct algorithms (panel a) and the
       response times in s (panel b) for the indefinite-length problems as a                                                 valid test of the likely ability of naive individuals as
       function of the sort of rearrangement, and whether they occurred in                                                   computer programmers (e.g., Bornat, Dehnadi, & Simon,
       the first or second block of trials.                                                                                  2008). The rearrangement problems in our experiments
                                                                                                                             may provide the basis for such a test. At the very least, we
       and much better than the indefinite-length problems (52%                                                              now know that individuals differ reliably in their ability
       correct; Wilcoxon test, z = 3.5, p = .0004; Cliff’s δ = .64).                                                         both to solve problems in the railway domain (Experiment
       Figure 2 accordingly shows only the performance for the                                                               1), and to formulate informal algorithms for their solutions
       indefinite-length problems, and the Appendix provides                                                                 (Experiment 2). The question remains as to whether such
       examples of participants’ correct algorithms. The three sorts                                                         tasks are reliable predictors of ability. Mathematicians,
       of rearrangement yielded the predicted trend in accuracy                                                              logicians, and computer programmers, learn to reason about
       and in the time to respond (see Appendix; Page’s trend tests,                                                         the repeated loops of operations that are needed in recursive
       zs > 3.08, ps < .002). Likewise, the participants used many                                                           functions. Previous studies have examined how novice
       more while-loops (74% of correct solutions) than for-loops                                                            programmers cope with such reasoning in trying to specify
       (26% of correct solutions) for indefinite-length problems.                                                            algorithms in a programming language (see, e.g., Anderson
       The use of while-loops correlated with accuracy (r = .32, p                                                           & Jeffries, 1985). Our studies have shown that naive
       < .0005), whereas the use of for-loops did not (r = .14, p =                                                          individuals with no training in computer programming are
       .10). The differences in ability were striking: the best                                                              able to make simulation-based deductions, to solve
       participant created a correct algorithm for every problem,                                                            rearrangement problems, and even to abduce informal
       whereas the worst did so for only a third of the fixed-length                                                         algorithms for their general solution.
       problems and for none of the indefinite-length problems.                                                                 The evidence we have reported corroborated the theory
                                                                                                                             based on mental models. To the best of our knowledge, no
                                       General Discussion                                                                    other theory of naïve algorithmic creativity exists. But, a
          The ability to create algorithms might seem to be a case                                                           theory could be developed in principle from an
       of competence in pure mathematics with little relation to                                                             axiomatization of the domain in first-order logic (see, e.g.,
       everyday life. Problems in rearranging cars in toy trains may                                                         McCarthy & Hayes, 1969; McCarthy, 1986; Rips, 1994). A
       similarly seem remote from the exigencies of daily life.                                                              typical axiom would capture the effects of a move, e.g.:
       However, algorithmic thinking is regularly called for, e.g.,
       in laying place settings on a table, in determining kinship                                                               For any x, y, if x is a car & y is a train & z is a train
       relations, in following a recipe or a set of instructions. Other                                                          & y is on right track & z is on left track & x is at
       sorts of algorithmic thinking are needed to determine the                                                                 the front of y & R 1 is carried out then x is at back
       consequences of knitting patterns, instructions for kits,                                                                 of z & not (x is at front of y).
       maintenance manuals, and, above all, algorithms in
       computer programs.                                                                                                    No one has proposed such an account, and so it is not yet
          Algorithmic thinking is easier when you can manipulate                                                             possible to pit it against the model-based theory. But, we
       an external environment and solve a problem using only                                                                cannot rule it out, and remark only that the approach runs
       partial means-ends analysis, i.e., you can use the railway                                                            into difficulties. Our participants’ think-aloud protocols
       environment and solve a rearrangement of the cars in a train,                                                         raise problems for it, because they report moving cars
       one car at a time (Experiment 1). But suppose that your task                                                          around in a mental simulation of the railway environment.
       is to devise an algorithm for the general problem of sorting                                                          Likewise, their reliance on simulations predicts their use of
       cars in this way – so that cars in odd-numbered positions                                                             while-loops in algorithms, because simulations yield the
       precede cars in even-numbered positions. The algorithm for                                                            halting conditions for while-loops more readily than the
       this task is not obvious. According to the present theory, the                                                        number of iterations for for-loops. These results seem
       way that you carry it out is to make another simulation so                                                            difficult, if not impossible, to explain without recourse to
       that you can figure out what is going on. You should then                                                             the use of mental simulations.
                                                                                                                          2702

                     Acknowledgements                                          comparative, developmental, and cognitive psychology. Behavioral
                                                                               and Brain Sciences, 21, 803-865.
This research was supported by a National Science                           Hegarty, M. (2004). Mechanical reasoning as mental simulation.
Foundation Graduate Research Fellowship to SSK and by                          Trends in Cognitive Sciences, 8, 280-285.
NSF Grant No. SES 0844851 to PJL to study deductive and                     Holt, R.W., Boehm-Davis, D., & Schultz, A. (1987). Mental
probabilistic reasoning. We are grateful to Monica                             representations of programs for students and professional
                                                                               programmers. In Empirical Studies of Programmers: Second
Bucciarelli, Sam Glucksberg, Adele Goldberg, Geoffrey                          Workshop (pp. 33-46). Ablex Publishing Corp.
Goodwin, Louis Lee, David Lobina, Max Lotstein, Robert                      Johnson-Laird, P.N. (1983). Mental models. Cambridge: Cambridge
Mackiewicz, Paula Rubio, and Carlos Santamaria, for their                      University Press.
helpful comments and criticisms.                                            Khemlani, S., & Johnson-Laird, P.N. (2012). Theories of the
                                                                               syllogism: A meta-analysis. Psychological Bulletin, 138.
                                                                            Kitzelmann, E., Schmidt, U., Mühlpfordt, M., & Wysotzki, F. (2002).
                             References                                        Inductive synthesis of functional programs. In Calmet, J.,
Anderson, J.R., & Jeffries, R. (1985). Novice Lisp Errors: Undetected          Benhamou, B., et al. (Eds.) Artificial Intelligence, Automated
  losses of information from working memory. Human-Computer                    Reasoning, and Symbolic Computation. New York: Springer.
  Interaction, 1, 107-131.                                                  Kurland, D. M., & Pea, R. D. (1985). Children’s mental models of
Anderson, J. R., Pirolli, P., & Farrell, R. (1988). Learning to program        recursive LOGO programs. Journal of Educational Computing
  recursive functions. In M. Chi, R. Glaser, & M. Farr (Eds.), The             Research, 1, 235-244.
  nature of expertise (pp. 153-183). Hillsdale, NJ: Erlbaum.                Miller, L. (1974). Programming by non-programmers. International
Boehm-Davis, D., & Ross, L. (1992). Program design methodologies               Journal of Man-Machine Studies, 6, 237-260.
  and the software development process. International Journal of            Miller, L. (1981). National language programming: Styles, strategies,
  Man-Machine Studies, 36, 1-19.                                               and contrasts. IBM Systems Journal, 20, 184-215.
Bornat, R., Dehnadi, S., & Simon (2008). Mental models, consistency         Newell, A. (1990). Unified theories of cognition. Cambridge, MA:
  and programming aptitude. Proceedings of the Tenth conference on             Harvard University Press.
  Australasian Computing Education Conference, 10, 53–61.                   Newell, A., & Simon, H.A. (1972). Human problem solving.
Caspersen, M.E., Bennedsen, J., & Larsen, K.D. (2007). Mental                  Englewood Cliffs, NJ: Prentice-Hall.
  models and programming aptitude. ACM SIGCSE Bulletin, 39.                 Oaksford, M., & Chater, N. (2007). Bayesian rationality. Oxford:
Corballis, M. (2011). The recursive mind. Princeton: Princeton                 Oxford University Press.
  University Press.                                                         Pane, J.F., Ratanamahatana, C.A., & Myers, B.A. (2001). Studying the
Craik, K. (1943). The Nature of Explanation. Cambridge, UK:                    language and structure in non-programmers’ solutions to
  Cambridge University Press.                                                  programming problems. International Journal of Human-Computer
Gulwani, S. (2010). Dimensions in program synthesis. In Proceedings            Studies, 54, 237-264.
  of the 12th International ACM SIGPLAN Conference. Hagenberg,              Rips, L.J. (1994). The psychology of proof. Cambridge, MA: MIT
  Austria.                                                                     Press.
Halford, G.S., Wilson, W.H., & Phillips, S. (1998). Processing              Tenenbaum, J. B., & Griffiths, T. L. (2001). Generalization, similarity,
  capacity defined by relational complexity: Implications for                  and Bayesian inference. Behavioral and Brain Sciences, 24.
Appendix. Natural language solutions (as outputted by the computer program for abducing them) to three sorts of general
problem: reversals, palindromes, and parity sorts, and examples of correct algorithms created by participants; and the
percentage of participants’ algorithms that correctly solved the given problems in Experiment 2.
Problem           Automatically generated algorithms                        Examples of correct algorithms                          % Correct
                  1 Move one less than the cars to siding.                  “i'll move everything in the side track. then
                  2 While there are > zero cars on siding
                                                                            i'll move each letter back onto the left track
Reversal          3 ...move one car to right track                                                                                       90%
                  4 ...move one car to left track.                          and then to the right track.” (Participant 14)
                  5 Move one car to right track.
                                                                            “step1: cut the train into half, move the right
                                                                            half to siding
                  1 Move one less than half the cars to siding.
                  2 While there are > two cars on left track
                                                                            step2: for both half trains on the left and
Palindrome        3 ...move two cars to right track                         siding track, move a pair of carts of the                    68%
                  4 ...move one car to left track.                          same letter to the right. Continue doing so
                  5 Move two cars to right track                            until all the carts are on the right track.”
                                                                            (Participant 1)
                                                                            “Move the rightmost car to the right track,
                  1 While there are > two cars on left track
                  2 ...move one car to right track
                                                                            and move the next car to the side track.
                  3 ...move one car to siding.                              Continue alternating between right track
Parity sort       4 Move one car to right track.                            and side track until the left track is empty.                55%
                  5 Move one less than half the cars to left                Then move all cars from the side track to
                    track
                  6 Move half the cars to right track
                                                                            the left track, and then to the right track.”
                                                                            (Participant 7)
                                                                        2703

