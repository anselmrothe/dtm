UC Merced
Proceedings of the Annual Meeting of the Cognitive Science
Society
Title
A Connectionist model of Planning via Back-chaining Search
Permalink
https://escholarship.org/uc/item/8pp5c7g3
Journal
Proceedings of the Annual Meeting of the Cognitive Science Society, 24(24)
Authors
Garagnani, Max
Shastri, Lokendra
Wendelken, Carter
Publication Date
2002-01-01
Peer reviewed
 eScholarship.org                                 Powered by the California Digital Library
                                                                    University of California

              A Connectionist Model of Planning via Back-chaining Search
                             Max Garagnani                     Lokendra Shastri and Carter Wendelken
                        Department of Computing                  The International Computer Science Institute
                           The Open University                               Berkeley, CA 94704 USA
                     Milton Keynes, MK7 6AA - UK                           Shastri@ICSI.Berkeley.EDU
                       M.Garagnani@Open.ac.uk                             CarterW@ICSI.Berkeley.EDU
                             Abstract                           event or situation (Shastri, 2001b; 2002). We assume that
                                                                a planning agent is capable of remembering past events
   A connectionist model for emergent planning behavior is      such as “performing action under conditions lead to
   proposed. The model demonstrates that a simple plan-         consequences ”. Each episodic memory trace of this
   ning schema, acting in concert with two general purpose
   cognitive functionalities, namely, episodic memory and       type can be represented as a triple of the form Precon-
   perception, can solve a restricted class of planning prob-   ditions, Action, Consequences, and we will refer to such
   lems by backchaining from the goal to the current state.     triples as PAC memories (or events) 1 .
   In spite of its simple structure, the schema can search for     Finally, we assume that the planning agent is capable
   and execute plans involving multiple steps. We discuss
   how this simple model can be extended into a more pow-       of observing the current world state through perception.
   erful and expressive planning system by incorporating ad-    By this we mean that the agent can determine whether or
   ditional control and memory structures.                      not certain perceptually salient and directly observable
                                                                relations hold in the world. For example, in the context
                                                                of the classical blocks world scenario, this assumes that
                        Introduction                            the agent can look at the table and determine whether or
Consider a classical planning problem, specified by an          not a specific block is ‘clear.’
initial state, a goal state and a set of operators. A direct
approach to solving this problem consists of searching                 A memory-based planning schema
the state space to find a ‘path’ between the initial and fi-    Figure 1 shows the abstract structure of the proposed
nal states. Several symbolic planning systems adopting          planning schema. In order to explain its behavior, let us
this approach in conjunction with the use of heuristics         describe the functionality of each of its components and
(Hoffman & Nebel, 2001; Haslum & Geffner, 2000; Bac-            their interactions using a simple example.
chus & Teh, 1998) have recently shown notable improve-
ments in efficiency on various benchmark problems.                Episodic                                         Observable
   Although a state space search algorithm is conceptu-           Memory                                           World state
ally simple, it is not obvious how the data structures and                                subgoal i+1
control mechanisms required for the specification and                        RECALL                   COMPARE
execution of such an algorithm can be realized in a neu-
rally plausible manner. In this paper we propose a con-                                fail    subgoal i+1
nectionist model that exhibits a state-space search behav-                  subgoal
ior. The model uses only a few simple control structures                            i                      match?
in conjunction with essential cognitive faculties, such as                                CURRENT
episodic memory, semantic memory, and perception.                                           GOAL
   Episodic memory (Tulving, 1995) refers to our abil-
ity to remember specific events and situations in our                           Goal                  Success/Failure
daily lives. The use of memory and experience in plan-
ning and reasoning has been investigated by several re-         Figure 1: A block diagram showing the basic compo-
searchers (see (Waltz, 1995; Spalazzi, 2001) for useful         nents of the planning mechanism.
accounts). Neurological and psychological data strongly
suggests that episodic memory is distinct both in its
                                                                   Consider a planning problem with only two blocks
functional characteristics and neural basis from other
                                                                (‘A’ and ‘B’) where the agent’s goal           is to achieve
forms of memories such as semantic memory, memory
                                                                On(A,B) (i.e. block A on block B) and the current
for common sense knowledge, and procedural knowl-
                                                                world state is On(B,A). Let us assume that the agent’s
edge. It has been argued that events and situations in
                                                                episodic memory contains the two PAC events E and E :
episodic memory are best viewed as relational instances
that specify a set of bindings between the roles of a rela-         1
                                                                      Note that preconditions and consequences may contain
tional schema and objects that fill these roles in a given      multiple predicates.

E      In state  P   = On(B,A) ,                                    At this point, one loop is completed and the procedure
       action    A   = Unstack(B,A)                                 repeats from step (2) with as the current goal.
       led to    C   = OnTable(A),OnTable(B) ;                         If C URRENT G OAL receives a positive input from
E      In state  P   = OnTable(A),OnTable(B) ,                      C OMPARE, the schema terminates returning Success and
       action    A   = Stack(A,B)                                   the control is given to an appropriate ‘Action schema’
       led to    C   = On(A,B) .                                    that will carry out the action currently active in memory
                                                                    ( ). If the original goal is not achieved via the execu-
(1) Initialize                                                      tion of this action, the planning schema is re-invoked and
The schema activity is initialized by conveying the goal            re-initialized with . Note that we are not assuming the
    ( On(A,B) in our example) as input to C UR -                    existence of a working memory which would allow the
RENT G OAL 2 . In the absence of any incoming activity              agent to dynamically store sub-goals during the planning
from C OMPARE, C URRENT G OAL simply passes con-                    process or to maintain active more than one PAC event at
trol along with the goal (subgoal               ) to the R ECALL    a time. Because of this, the proposed system is forced to
component. The behavior of the C URRENT G OAL com-                  ‘re-discover’ parts of the same plan every time an action
ponent in the presence of an input from C OMPARE is dif-            is executed, as described below.
ferent, and is described below.                                        Returning to the example, the result of C OMPARE
                                                                    is negative and no action is performed:          is ‘forgot-
(2) Recall                                                          ten’, while      becomes the new subgoal and is passed
R ECALL is activated when it receives the subgoal                   on to R ECALL. The schema now queries the episodic
(On(A,B), in the example) as input from C URRENT                    memory by asking if OnTable(A),OnTable(B)
G OAL. The function of this component is to search                  has been achieved in the past: PAC event E is recol-
episodic memory for an event wherein a specific action              lected. The precondition         = On(B,A) – required
(say, ) performed under some specific preconditions                 to perform Unstack(B,A) – becomes the new fo-
(say, ) lead to a set of consequences (say, ) in which              cus of attention and is compared with the current world
subgoal is true. In our example, E happens to be such               state, producing a successful outcome: a chain of (two)
an event. When a matching event is found, action                    PAC events connecting the goal to the initial state has
and preconditions are recollected and become ‘active’;              been found, and the planning problem has been (poten-
    becomes the current focus of the agent’s attention 3 ,          tially) solved. However, because of the absence of a
and control is transferred to C OMPARE, along with as               working memory able to dynamically store goals and
the current subgoal          . In the example, subgoal              subgoals, all the agent can ‘see’ at this point is the
           OnTable(A),OnTable(B) . If there are no                  last PAC event recollected. The currently active ac-
events whose consequences ‘match’ the subgoal , the                 tion ( =Unstack(B,A)), though, can and should
schema execution halts and signals a failure.                       be executed, since this will get the current state one
                                                                    step closer to the goal. After the positive outcome of
(3) Compare                                                         C OMPARE, the schema terminates returning ‘Success’:
                                                                    the agent carries out the currently active action Un-
The C OMPARE block compares subgoal                   with the cur-
                                                                    stack(B,A), and the new state of the world becomes
rent world state, which is assumed to be observable
                                                                      OnTable(A),OnTable(B) .
through perception. It returns a positive outcome iff
                                                                       After the action has been completed, the agent is
subgoal         is true in the current state. In the example,
                                                                    ‘re-exposed’ to the initial goal          (which has not
the response is negative, as the world is still On(B,A).
                                                                    been achieved yet), and the planning schema is re-
After the comparison, the outcome and the subgoal
                                                                    invoked. The subsequent flow of activity is iden-
(= ) are passed to C URRENT G OAL, which takes con-
                                                                    tical to the first part of the previous one, except
trol of the activity and reacts as explained below.
                                                                    that now = OnTable(A),OnTable(B) matches
                                                                    the current state of the world, and thus action           =
(4) Repeat
                                                                    Stack(A,B) is executed. This leads to achieving the
If C URRENT G OAL receives a negative result from                   original goal , and the schema is no longer invoked.
C OMPARE, the following happens:
                                                                           The connectionist planning schema
   the original goal is no longer passed as input to R E -
   CALL , and ceases driving the activity of the schema;            The planning mechanism described above has been
                                                                    implemented using the representational machinery of
   the set of preconditions (=subgoal               ) becomes the   SHRUTI , a neurally plausible structured connectionist ar-
   new subgoal and is passed to R ECALL by the C UR -               chitecture that demonstrates how a network of neuron-
   RENT G OAL component.                                            like elements can encode a large body of structured
    2                                                               knowledge and perform a variety of inferences within a
      It is assumed that this goal is represented in other networks
outside the planning schema and communicated to the schema          few hundred milliseconds (Shastri & Ajjanagadde, 1993;
via controlled spreading activation.                                Shastri, 1999; Shastri & Wendelken, 2000).
    3
      In order to achieve the original goal , it suffices to           SHRUTI suggests that the encoding of relational infor-
achieve and execute action .                                        mation (frames, predicates, and schemas) is mediated by

neural circuits composed of focal-clusters, and that the       OnTable(B) from the precondition On(B,A).”
dynamic representation and communication of relational
instances involves the transient propagation of rhythmic
                                                                                 +e     +v  Block      ?v     ?e
activity across these clusters. A role-entity binding is
represented in this rhythmic activity by the synchronous
firing of appropriate cells. Rules are encoded by links
that enable the propagation of rhythmic activity across
focal clusters, and a fact in long-term memory is a tem-
                                                                         +    A     ?                       +    B     ?
poral pattern matching circuit.
    In the past, SHRUTI’s representational machinery has
been used to encode commonsense knowledge (Shastri
& Ajjanagadde, 1993), causal models (Shastri & Wen-                                                      On(B,A)
delken, 2000), as well as action schemas and reactive                        OnTable(B)
plans (Shastri, Grannes, Narayanan & Feldman, 1997)                                               + ?       On      x      y
and decision-making (Wendelken, 2001).                                    OnTable(A)
A memory-based proto-planner                                          + ? OnTable      x
                                                                                                                  to
                                                                                                                    OnTable(A) &
Consider the network structure depicted in Figure 2.                                                                OnTable(B)
This network fragment consists of two ‘control’ focal-
clusters ACHIEVE and RECALL, two predicate focal-                                + ? Unstack      x     y
                                                                      to
clusters On and OnTable, an action focal-cluster Un-                 On(B,A)                                           [ p1 ; a1 ; c1 ]
stack, two entity focal-clusters A and B, and a type                                                                         ...
focal-cluster Block. Typically, a focal-cluster contains
                                                                                                                     [ pj ; a j ; c j ]
several control and role nodes. For example, the focal-
cluster ACHIEVE contains control nodes +, -, and ?, and                              [ On(B,A); Unstack(B,A); {OnTable(A),
                                                                                                                 OnTable(B) }
                                                                                                                                    ]
role nodes and (the entity and type focal-clusters do
not contain role nodes).
    Role nodes within the focal-cluster of a predicate or                    + −      ?      RECALL       P    A    C
schema provide a mechanism for expressing role (or pa-
rameter) bindings. In particular, a dynamic binding be-
tween a role and its filler is expressed by the synchronous
firing of the role node and the focal-cluster of the object                                 +     ?
filling the role. A relational focal-cluster with bound role
nodes designates a particular relational instance.
    The enabler (?) node associated with a focal-cluster
may be viewed as an “initiate query” or “initiate activ-                     + −     ?      ACHIEVE         I      G
ity” node. In contrast, collector nodes (+ and –) associ-
ated with a focal-cluster indicate the outcome of a query
or of other activity pertaining to the focal-cluster. In par-  Figure 2: diagram showing network structure for a proto-
ticular, the activation of the + (–) collector indicates a     planning mechanism.
positive (negative) response to a query or signals a suc-
cessful (unsuccessful) completion of some activity.               Fact structures attached to a relational focal-cluster en-
    Inference occurs via the propagation of activity be-       code specific instances of that relation. If the query active
tween focal-clusters. The links between the enabler and        at a focal-cluster matches an attached fact, the fact be-
role nodes of interconnected focal-clusters allow queries      comes active and, in turn, activates the positive collector
posed in one focal-cluster to propagate to other focal-        of the relation’s focal-cluster, binding (via synchronous
clusters: if role node        is linked to role node     , the firing) each of the relation’s role nodes to the entity fill-
firing of      induces synchronous firing in       , allowing  ing these roles in the fact. A neurally plausible model of
dynamic binding propagation.                                   how this might happen in the brain is described in (Shas-
    A query is communicated to a focal-cluster by acti-        tri, 2001b).
vating its enabler node and binding its role nodes to ap-         In the case of RECALL, the facts structures attached to
propriate role fillers. In Figure 2, the query “Can block      this focal-cluster represent episodic memories of specific
B be placed on the table, given that B is on A?” is            PAC events. The activation of the query “Is there some
communicated by activating ?:ACHIEVE, and synchro-             action which led to OnTable(B) from the precondi-
nizing the firing of ACHIEVE.I and +:On; the firing            tion On(B,A)” matches the memorized PAC event and
of ACHIEVE.G and +:OnTable; the firing of On.x,                leads to this event becoming active (i.e., recalled). This
OnTable.x and ?:B; and that of On.y and ?:A. The               in turn results in the activation of +:RECALL and the
activity of ACHIEVE propagates to the RECALL cluster,          synchronous firing of the unbound role RECALL.A with
resulting in the query “Is there some action which led to      the representation of Unstack(B,A): the system re-

calls that performing Unstack(B,A) when On(B,A)            new (sub)goal of the schema, and its focus of attention.
was true lead to OnTable(B) being true.                    Activity from ?:SUBGOAL reaches ?:RECALL again,
   An important feature of the system consists of its      while role node C starts firing in synchrony with G. This
ability to treat a relational instance as a role-filler    leads to the retrieval of PAC event E , and hence, the pre-
(e.g. ACHIEVE.I          On(B,A)). In order to support     condition P = On(A,B) gets bound to role P and role
this requirement, SHRUTI allows for two levels of tem-     A is bound to the action instance A = Unstack(B,A).
poral synchrony. Bindings between standard role nodes      These bindings are in turn propagated to COMPARE.
and entity/type nodes are represented within a rapid mi-
nor oscillatory cycle, while bindings between specialized                                    OBSERVABLE
                                                                                              WORLD STATE
role nodes and relational instances are encoded within a      EPISODIC (P1, A1, C1)
                                                                       (P2 ,A2, C2)                               PERCEPTION
slower major oscillatory cycle.                               MEMORY       ....
   The simple schema described above, consisting of the
ACHIEVE and RECALL clusters acting in concert with
the episodic memory, can retrieve previously memorized            ? +                RECALL          COMPARE    ?  +        P
                                                                        P A        C
‘if-then’ (PAC) tuples. Thus, this schema can be con-
strued as a proto-planner capable of returning one-step                                                  to +:SUBGOAL
‘plans.’ The next section demonstrates how this schema
can search for sequences of actions, therefore constitut-                                      SUBGOAL
ing the next ‘stage of evolution’ of this proto-planner.                                    ?  +
                                                                                                       G
The planning schema in SHRUTI
Figure 3 shows how the planning schema of Figure 1 has
been implemented using SHRUTI’s representational ma-
chinery. It is easy to see how the focal clusters of this
schema can be mapped to the elements of Figure 1 (the                                 PLAN  ?  +       G
C URRENT G OAL block has been realized with two clus-          EXECUTE
                                                                ACTION
ters, PLAN and SUBGOAL). We shall use the same ex-              Schema          from                           FAILURE
ample adopted earlier to illustrate how the schema can                   ACHIEVE
                                                                                                      SUCCESS
perform a basic form of planning as search.
   Let us assume that the memory of the agent (repre-      Figure 3: A diagram showing the connectionist structure
sented only abstractly in the figure) contains the two PAC of the planning schema.
events of the previous example, namely, E = (P , A ,
C ) and E = (P , A , C ), and that the P ERCEPTION
block, when queried with input P, activates the + or –         The positive outcome of the comparison leads to
collector depending on whether the event bound to P is     the activation of +:COMPARE, which communicates to
true or false in the observed world state.                 PLAN that the search has terminated successfully. After
   The schema is invoked by activating the PLAN clus-      action A is executed, the initial goal = On(A,B)
ter’s enabler (‘?’) node and by binding its role node      (not yet achieved and still present in the system) causes
G to the relational instance expressing the current goal   the schema to restart. The subsequent flow of activation
(On(A,B) in the example). After initialization, activ-     is identical to the initial part of the previous sequence,
ity propagates upwards along links to clusters SUBGOAL     except that when P = OnTable(A,B) is compared
and RECALL. After few major cycles, ?:RECALL is ac-        with the current state, the outcome is positive and the
tivated, with role C firing in synchrony with the cur-     currently active action (Stack(A,B)) is executed. This
rent goal On(A,B) . The PAC event E matches the            achieves the goal and terminates the activity.
activity in the cluster and is retrieved. Consequently,
+:RECALL becomes active, and the roles A and P are                                  Simulation results
instantiated with actions A = Stack(A,B) and rela-         The above planning schema has been realised and tested
tional instance P = OnTable(A,B) , respectively            using the “S HRUTI Agent Simulator” software written in
(the clusters corresponding to predicate ‘OnTable’ and     Java. The example described in the previous section has
action ‘Stack’ are not shown in the figure). The ac-       been used to test the functioning of the schema. Figure 4
tivity of P reaches COMPARE. Since OnTable(A,B)            shows the detailed trace of activation resulting from the
is not true in the current world state, -:Compare be-      actual simulation. Note how the diagram reflects closely
comes active. This leads to the inhibition of the links    the flow of activity described before, up to the first posi-
from PLAN to SUBGOAL, which blocks the propaga-            tive outcome of COMPARE.
tion of the query PLAN(On(A,B)) through the schema.            Consider, for example, time point                   of the dia-
Simultaneously, activity from COMPARE reaches SUB-         gram. Here, the PAC fact E has just become ac-
GOAL: the role node G starts firing in synchrony with      tive because of the initial query ‘PLAN(On(A,B))’,
P, which was temporally bound to the relational in-        which has been propagated upwards and has led to the
stance OnTable(A,B) . Hence, this becomes the              query ‘RECALL( , ,On(A,B))’. As a consequence,

the two preconditions OnTable(A),OnTable(B)                       path from the goal to the initial state, it can get caught
are about to become active, and will be propagated to the         in a state that subsumes a set of conditions          which
COMPARE cluster, where they will be matched against               do not match the consequent of any PAC event in mem-
the current state of the world 4 .                                ory. There is, however, a simple three part solution to
                                                                  this problem. First, the agent detects that it has reached
                 ?                                                a deadend state (this is signaled by the activation of -
       PLAN      +                                                :RECALL. Second, the agent memorizes that this path
                 g                                                leads to a deadend in the context of the current prob-
                                                                  lem. It can do so by memorizing the following episodic
       SUBGOAL
                 ?
                 +                                                memory trace: ìwhen trying to achieve the goal , in-
                 g                                                stantiating a subgoal leads to a deadendî. 5 Third, the
                 ?                                                agent restarts the search and at each step in the search
                 +                                                process retrieves both PAC and DEADEND events that
       RECALL
                 p                                                match the current subgoal. Any retrieved PAC event that
                 a                                                is counterindicated by retrieved DEADEND event is ig-
                 c                                                nored. Since the memorization of deadends prunes the
                 ?                                                potential search space, with suf cient practice, the agent
       COMPARE
                 +                                                may memorize a large number of deadend events and
                                                                  carry out a highly ef cient search.
                 p                                                   Another limitation of the proposed planning schema
    On(A,B)                                                       is that it needs to traverse the same paths through the
    On(B,A)                                                       state space several times during the course of nding a
                                                                  plan. However, if the agent could remember the path
 OnTable(A)
  /\ OnTable(B)       α
                                                                  traversed from the current goal to the initial state, it
                                      β
                                                                  would not have to rediscover the same plan subsequences
                                                                  many times over: plan execution would involve travers-
    Figure 4: Node activation trace of the simulation.
                                                                  ing the memorized sequence of PAC events only once (in
                                                                  the reverse order) and executing the actions associated
   Time point is a snapshot of the situation immedi-              with each PAC event in the sequence. Note that remem-
ately following the negative outcome of the (simulated)           bering such a path can be viewed as memorizing a se-
comparison. Notice how the ow of activity going from              quence of PAC events. Learning of event sequences is a
the PLAN cluster to the RECALL cluster has been inter-            well-known property of episodic memory, but it remains
rupted by the negative outcome of COMPARE in order to             to be seen how the process of such on-line memoriza-
allow the new goal OnTable(A),OnTable(B) to                       tion of event sequences can be fully integrated with the
make its way through to cluster RECALL.                           on-line retrieval of previous episodic memories. Work-
                                                                  ing memory mechanisms can also play a complementary
                       Discussion                                 role in such on-line memorization. Our current research
The work described in this paper is part of a larger effort       addresses the functioning of episodic memory (Shas-
whose goal is to develop a neurally plausible architec-           tri, 2001b; 2002) as well as that of working memory,
ture for reasoning, remembering, planning, and decision           and we hope that the development of powerful episodic
making. This paper presents progress along an important           and working memory models will directly bene t future
dimension of this ongoing effort. Perhaps the most inter-         work in the development of planning schemas.
esting aspect of this work is the demonstration that gen-            Since the proposed planning schema operates within
eral purpose cognitive faculties such as episodic mem-            the SHRUTI architecture, the full range of knowledge
ory, semantic memory and perception can be harnessed              representation and reasoning capabilities of SHRUTI can
to produce a state-space search behavior and solve a sub-         be leveraged during planning. This includes represent-
class of planning problems.                                       ing and reasoning with commonsense (semantic) knowl-
   The planning schema discussed in this paper is limited         edge, causal models, type hierarchies, context-sensitive
in a number of ways; however, as discussed below, this            prior probabilities of events and estimated utility/value of
schema can be extended into a much more powerful and              world-states. Thus, general purpose domain knowledge
expressive planning system by incorporating additional            as well as planning speci c knowledge can be seamlessly
control and memory structures, and by leveraging the full         combined to support planning involving not just memory
representational and expressive power of SHRUTI.                  retrieval, but also inference.
   The proposed planning schema is susceptible to get-               The functionality of the current planning schema is
ting trapped in deadends. As the system searches for a
                                                                     5
                                                                      The representational machinery required to encode such
   4
     The perceptual task of verifying whether some conditions     DEADEND     ìeventsî is similar to that required to encode PAC
hold in the current world state was simulated by manually acti-   events: like PAC events, the episodic memory trace of DEAD -
vating the or collector of the cluster ëCompareí as appro-        END events also involves role- llers that are partial state-
priate.                                                           descriptions, speci ed by sets of conditions.

also limited by its inability to make use of goal decompo-        Hoffmann, J., & Nebel, B. (2001). The FF Planning Sys-
sition. Imagine that the agent is trying to nd a plan for           tem: Fast Plan Generation Through Heuristic Search.
the goal            given the world state and the two PAC           Journal of Artificial Intelligence Research, 14, 253ñ
events PAC                  and PAC                  in memory.     302.
The planning schema described in this paper will be un-           Malenka, R. C., & Nicoll, R. A. (1999). Long-term Po-
able to solve the composite goal           &      , even though     tentiation - A Decade of Progress? Nature, 285, 1870ñ
it will be able to solve each of the subgoals            and        1874.
if presented individually 6. In order to deal with goal de-
composition, the schema must (i) recognize that it can            Shastri, L. (1999). Advances in SHRUTI - a neurally mo-
solve one of the subproblems using one of the PAC facts,            tivated model of relational knowledge representation
(ii) pick the subproblem to be solved, (iii) note down the          and rapid inference using temporal synchrony. Ap-
subproblem that it is deferring for now, (iv) nd a solu-            plied Intelligence, 11.
tion to the selected subproblem, (v) shift attention back         Shastri, L. (2001a). A Biological Grounding of Recruit-
to the deferred subproblem, and (vi) solve the deferred             ment Learning and Vicinal Algorithms. In J. Austin,
subproblem. A connectionist implementation of this al-              S. Wermter & D. Wilshaw (Eds.), Emergent neural
gorithm would require a more complex schema (control                computational architectures based on neuroscience.
structure) than the one described in the previous sections,         Springer-Verlag.
together with the ability to remember deferred goals. The         Shastri, L. (2001b). A computational model of episodic
memory of deferred goals can take the form of working               memory formation in the Hippocampal system. Neu-
memory (if deferred goals have to be remembered for a               rocomputing, 38-40, 889ñ897.
few seconds) or episodic memory (if the goals have to be
remembered over longer time periods).                             Shastri, L. (2002). Episodic memory and cortico-
                                                                    hippocampal interactions. Trends in Cognitive Sci-
   Another area of ongoing research of direct relevance
                                                                    ences, 6(4), 162ñ168.
to the work described here concerns the representation
of complex action schemas and plans. In past work, we             Shastri, L., & Ajjanagadde, V. (1993). From simple as-
have shown that parameterized schemas capable of deal-              sociations to systematic reasoning. Behavioral and
ing with partially ordered actions, conditional actions,            Brain Sciences, 16(3), 417ñ494.
concurrent and iterative actions, as well as compositional        Shastri, L., Grannes, D., Narayanan, S. & Feldman, J.
and hierarchical actions can be encoded using SHRUTIís              (1997). A Connectionist Encoding of Parameterized
representational machinery (Shastri et al., 1997). This             Schemas and Reactive Plans. In G. Kraetzschmar
makes us con dent that the more complex control struc-              and G. Palm (Eds.), Hybrid Information Processing in
tures required for encoding more sophisticated planning             Adaptive Autonomous Vehicles. Springer-Verlag.
schemas would not present an insurmountable problem.
                                                                  Shastri, L., & Wendelken, C. (2000). Seeking coherent
   A key issue that remains open is the learning of appro-          explanations - a fusion of structured connectionism,
priate control structures. We are investigating this ques-          temporal synchrony, and evidential reasoning. Pro-
tion within the frameworks of spike-timing dependent                ceedings of the Twenty-Second Conference of the Cog-
synaptic plasticity (Wendelken & Shastri,2000; Song,                nitive Science Society. Philadelphia.
Miller & Abbott, 2000) and recruitment learning based
on long-term potentiation (Malenka & Nicoll, 1999;                Song, S., Miller, K., & Abbott, L. (2000). Competitive
Shastri, 2001a).                                                    Hebbian Learning Through Spike-Timing Dependent
                                                                    Synaptic Plasticity. Nature Neuroscience, 3, 919ñ926.
                    Acknowledgments                               Spalazzi, L. (2001) A Survey on Case-Based Planning.
                                                                    Artificial Intelligence Review, 16(1), 3ñ36.
This work was partially funded by NSF grants 9720398
and 9970890.                                                      Tulving, E. (1995) Organization of Memory: Quo Vadis?
                                                                    In M.S. Gazzaniga (Ed.), The Cognitive Neuroscience.
                         References                                 MIT Press.
Bacchus, F., & Teh, Y. W. (1998). Making forward                  Waltz, D.L. (1995) Memory-based reasoning. In: M. A.
   chaining relevant. Proceedings of the Fourth Inter-              Arbib (Ed.), The Handbook of Brain Theory and Neu-
   national Conference on AI Planning Systems (AIPS                 ral Networks. MIT Press.
   1998) (pp. 54ñ61).                                             Wendelken, C., & Shastri, L. (2000). Probabilistic infer-
                                                                    ence and learning in a connectionist causal network.
Haslum, P., & Geffner, H. (2000). Admissible Heuristics             Proceedings of the Second International Symposium
   for Optimal Planning. Proceedings of the 5th Internat.           on Neural Computation.
   Conf. of AI Planning Systems (AIPS 2000) (pp. 140ñ
   149). Breckenridge, Colorado: AAAI Press.                      Wendelken, C. & Shastri, L. (2002). SHRUTI-agent:
                                                                    A structured connectionist model of decision-making.
    6
      That is, assuming that and         hold in state , and that   Proceedings of the 24th Conference of the Cognitive
    also holds in the state resulting from performing action        Science Society. Washington, D.C. August, 2002.
in state .

