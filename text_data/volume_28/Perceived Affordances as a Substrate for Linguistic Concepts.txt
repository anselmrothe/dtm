UC Merced
Proceedings of the Annual Meeting of the Cognitive Science
Society
Title
Perceived Affordances as a Substrate for Linguistic Concepts

Permalink
https://escholarship.org/uc/item/9dk4k3kk

Journal
Proceedings of the Annual Meeting of the Cognitive Science Society, 28(28)

Authors
Gorniak, Peter
Roy, Deb

Publication Date
2006-01-01
Peer reviewed

eScholarship.org

Powered by the California Digital Library
University of California

Perceived Affordances as a Substrate for Linguistic Concepts
Peter Gorniak (pgorniak@media.mit.edu)
Deb Roy (dkroy@media.mit.edu)
MIT Media Laboratory
Cambridge, MA 02139 USA
Abstract

results show that this implementation can accurately predict
how human players respond to spoken commands issued by
their human partners, demonstrating the viability of our approach for modeling the interpretation of context-dependent
language on the basis of perceived affordances.

We propose the use of perceived affordances to computationally model linguistic concepts in situated language use. Perceived affordances are mental structures that capture the relationship between the language user and the embedding situation. We employ computational models of human perceived
affordances to understand situated language: language that dynamically depends on the current physical environment and
the goals and plans of communication partners. To support
this theory of situated language understanding, we describe an
implemented system that understands verbal commands situated in a virtual gaming environment. The implementation
uses probabilistic hierarchical plan recognition to generate perceived affordances. We have evaluated the system on its ability
to correctly interpret free-form spontaneous verbal commands
recorded from unrehearsed game play between human players,
and find that it is able to “step into the shoes” of human players
and correctly respond to a broad range of verbal commands in
which linguistic meaning depends on social and physical context.

Related Work
There exist a number of competing or complementary theories of concepts. Laurence and Margolis as well as Prinz give
overviews of the proposals and the debates surrounding them
(Laurence and Margolis, 1999; Prinz, 2002). Many theories
of concepts adopt a fundamental bias: that the use of concepts
by an actual language using system, and thus their connection
to the world, is secondary to their internal structure and formal properties. This bias is exhibited most strongly by the
traditional definitional theories. Where they acknowledge a
link to the world at all, for example in the form of observation sentences (Carnap, 1932), the link is portrayed as simple
and passive. In fact, the only function usually considered is
that of categorization, a feature shared with Prototype Theory (Rosch, 1975). Closest in spirit to our proposal here is
perhaps Theory-Theory (Carey, 1985), but only in so far as it
acknowledges the importance of viewing concepts as embedded in a structure used to reason about particular domains.
While Theory-Theory emphasizes internal mental theories,
however, it leaves unspecified their connection to the world
except, again, in the case of categorization where it explains a
human tendency towards essentialism. All these theories thus
largely deal with internal mental structures and at most tackle
the problem of categorization using these mental structures.
Categorization is only one possible use of concepts, however,
and arguably not the most basic one. Concepts are intimately
tied to the goals of the conceptualizer and thus a theory of
concepts should not only explain categorization behaviour,
but more importantly cover intentional aspects of concepts
such as the predictions they imply, and generally their use in
achieving goals.
In a similar vein, the computational theories and systems
addressing the problem of how a word comes to be about the
world, treat this problem as one of adding sensory categorization functionality to a definitional theory of concepts (Harnad,
1990). There are a number of systems that have been built according to this paradigm, including Regier (1996)’s work on
learning words for spatial relations, Plunkett et al. (1992)’s
image labelling investigations, Yu, Ballard, and Aslins model
of word learning Yu et al. (2003), as well as some of our own
previous models of word grounding (Roy et al., 2002; Roy,
2002). These systems often address additional aspects of this
type of grounding, such as how categories are learned by the
language user (Regier, 1996; Roy, 2003) and how concepts
grounded in this way can be combined (Gorniak and Roy,
2004). We have previously presented work on understanding
situated language using plan recognition (Gorniak and Roy,
2005a,b), but that work separated the linguistic understanding
from the plan recognition, whereas they are tightly coupled

Introduction
We have recently introduced the theory of Affordance-Based
Concepts (ABCs) (Gorniak, 2005; Gorniak and Roy, 2006).
This theory has at its core the intentional link between language users and the world treating predicted interactions as
the basic building block for conceptual representation. Other
theories often limit themselves to specifying the structure of
concepts as opposed to how concepts come to be about the
world. To tightly couple the internal structure of concepts
with their intentional and functional use, the theory proposes
that each element of a concept must make a prediction about
the world, thus crossing over from the mind to the world. Every concept thus becomes both a property of the language using system, and of its relation to the embedding world. These
structural elements are called perceived affordances, yielding
a theory of Affordance-Based Concepts.
In this paper, we introduce a computational model that
employs plan recognition as a mechanism for finding and
ranking the perceived affordances of a person engaged in
co-operative tasks. Situated language interpretation is modeled as a process of filtering perceived affordances. In effect,
the complete meaning of linguistic expressions is only understood when words are meshed with the situation in which
they are used. To evaluate the model, we describe an implementation of the model that interprets situated language
collected from people playing a multiplayer computer game.
This implementation is based on a probabilistic, hierarchical
plan recognizer in the form of an Earley parser, To understand
the game players’ language, a syntactic parser filters the predictions (perceived affordances) this plan recognizer makes at
the time of an utterance. Language understanding thus is cast
as a filtering process on perceived affordances, which are elements that naturally span the boundary between the language
user’s mind (by virtue of being subjective predictions taking into account the language user’s goals) and the world (by
virtue of taking into account the structure of the world). Our
279

Note that so far we have not invoked the notion of objects
per se – perceived affordances are about the structure of the
world that can be exploited to make predictions. This structure can be below the level of everyday objects, for example
when it concerns the geometry of a graspable surface, which
may or may not be part of a larger structure that we usually
label “doorknob.” Having replaced the notion of objects with
the notion of structural elements called affordances, we can
now re-introduce objects as bundles of affordances. A doorknob yields a set of interactions, as determined by its physical
properties and the agent’s abilities. When we engage in an active process of representation to distinguish objects within the
structure of the world, we carve out a set of local affordances
in the world and consider it an object. This process is not arbitrary, however, as it exploits the pre-existing structure of the
world, including our own abilities. Thus while concepts of
objects are the product of our perception, representation and
actions, and while we may decide to cut up the world into
different sets of objects at different times, we are externally
constrained in our object categorizations by our own structure
and that of our environment.
In the following studies this unified representation of objects as bundles of perceived affordances lets us capture the
situation in terms of its possible functions for the agent. For
example, a door is represented by the uses an agent might
have for it, such as unlocking it, opening it or walking through
it. This lets us interpret language in a representational substrate that already includes predicted actions and abstractions
and thus turns understanding into a filtering process on this
substrate. For example, “open the door” selects a subset of
the perceived affordances of the listener in his or her present
situation that involve opening available doors.
Concepts of objects are instances of the more general class
of structures we call concepts. Each concept is a bundle of
perceived affordances. In addition to representing concrete
everyday objects, concepts can represent sets of structures in
the world not limited to a single agent and object. Allowing
arbitrary bundles of affordances gives the Affordance Based
Concept theory a unique representational power, but the use
of affordances imposes limits as it is subject to constraints
from the structure of subject and environment. One aspect of
this power is the ability to represent abstraction. For example, the command “let me into the next room” in our studies selects a more abstract interaction of changing rooms that
at lower levels expands out into the listener unlocking or destroying the door to the next room, or pulling the correct lever
to open it, followed by the speaker moving to the next room.
This is also an example of concept composition in which the
filter functions of lexical items are combined during the linguistic parsing process. Thus, while “room” selects sets of
affordances available in any single room in the virtual environment, “next room” selects only those requiring exactly one
room change by the speaker.

here. Few sensory grounded language systems can be found
that can act autonomously using the concepts they maintain.
Where action is involved, at hand is usually either once more
a sensory categorization problem (Siskind, 2001). Some systems, such as KARMA, do understand language in terms of
action representations, and these are perhaps most related to
the work presented here. So far, however, these systems have
not been shown to understand situated language dependent on
a dynamically evolving situation (Narayanan, 1997). There
exists work on computationally modelling affordances more
abstractly as a theoretical tool to explore linguistic mechanisms (Steedman, 2002), as well as in a non-linguistic setting
to model a robot’s interactions with the real world (Stoytchev,
2005). Our robotics work has led Roy to propose a theory for
grounding linguistic concepts in physical interaction (Roy,
2005). That work complements that presented here as a proposal for linguistic meaning based on interactions with the
world at a far more detailed and fine grained level of physical (sensory-motor) experience than considered here. Finally,
Fleischman and Roy (2005) have explored the word learning
problem using an intention recognition framework very similar to the one presented here, but focusing on the difference
between learning nouns and verbs.

Theory
The term affordance was coined by Gibson (1977). Rather
than focusing on image-like representations that are similar
to, or correspond to, the light information impinging on the
retina, he proposed that perception encodes what the external world affords the perceiver. Thus, extended surfaces are
perceived to provide support for walking on, if the surface
is of an appropriate size relative to the perceiver and sturdy
enough to hold the perceiver’s weight, and the perceiver is actually able to walk. Perceived affordances, those affordances
mentally represented by a perceiver, fulfill our requirements
of a representation: they are the product of perception of the
world, they encode some aspect of the structure of the world
relative to the perceiver, and they predict a possible interaction between perceiver and world. By implying a prediction,
they can be falsified.
In our context, a perceived affordance encodes some aspect
of the state of the world, as well as a prediction made based
upon this state. The world’s state might be represented by
encoding a fragment of the world’s history, as is common in
computational models. The perceived affordance’s prediction
may be representationally explicit, such as a list of possible
ways to pick up a cup, or it may be implicit, such as an encoding of the cup’s geometry together with a model of possible
hand movements and configurations. A perceived affordance
addresses the possible action prediction problem at a single
level of representation. The possible ways to pick up a cup
versus the choice of possible breakfast foods one faces every
morning are on very different levels of representation. They
are connected, however, in that a possible breakfast choice
may include pouring a cup of milk, and thus picking up a
cup. To make mental representation feasible it is important to
keep these levels of affordances related yet distinct. Keeping
them distinct allows one to reason on a single level, to achieve
more concise yet still approximately Markovian state encodings and to employ the representation and reasoning methods
that are best for that level. Keeping them loosely connected,
on the other hand, allows for predictions that span levels and
lets one fill in the details of high level plans, creating a hierarchy of perceived affordances.

Implementation
In the implemented system, the structure of perceived affordances hinges on the notion of a hierarchical plan. A plan is a
sequence of one or more steps an agent takes or considers taking. A hierarchical plan is a plan in which a top level node is
expanded into sequences of lower level nodes each of which
in turn may expand into yet lower level nodes. The leaves
of the plan structure form a non-hierarchical plan of concrete
actions the agent can actually take. Humans explicitly or implicitly maintain hierarchical plans all the time, such as when
280

performs a combination of top-down prediction and bottomup completion of parse trees to optimize its search behaviour
(Earley, 1970). An Earley parser is based on the notion of an
Earley state, a structure that concisely summarizes the state
of the parser at a particular point in the observation sequence,
and at one level of the current parse. That is, each state concerns exactly one grammatical rule, and marks how far in
this rule the parse has progressed. In the probabilistic Earley parser we use here (Stolcke, 1995), a state also computes
a probability of the grammar having produced the input sequence so far, and entering this state. We can take a state
that has not completed its grammatical rule (i.e. that still has
symbols left to parse in the tail of the rule) to be predicting the
next symbol in the tail with a certain probability. These states
are coloured green in Figure 1. Complete states (that have
successfully advanced beyond all the symbols in the rule tail)
correspond to the nodes in a parse tree - they assert that a
higher level element of the hierarchy is indeed present in the
input stream. These are coloured blue in Figure 1.
A parse state in an Earley parser used for plan recognition
is an ideal candidate for a computational manifestation of a
perceived affordance. Assuming that the parser is used to
recognize the plans of a particular agent, it 1) predicts possible future interactions with the world at a particular point in
time (the symbols to the right of the dot in the state), 2) ranks
the likelihood of possible future interactions given the interaction seen so far through its forward probability, 3) applies
to a particular level of abstraction, but is related to other levels
due to the hierarchical nature of the grammar and 4) summarizes a segment of past interaction to predict the future. As
an Earley parser progresses, it maintains complete state sets
for each point in time, thus providing a complete history of
past actions and predictions in addition to currently relevant
predictions. We call the grammar used by this Earley parser
an affordance grammar. This grammar is a predictive model
of the structure of the world, representing a certain agent’s
predictions about and possible interactions with the world.

planning to buy milk, which expands into going to the store
and purchasing milk, which in turn expands into walking to
the car, getting in the car, driving to the store, and so on. Hierarchical plans have the advantage of making independence
assumptions: if your goal is to buy milk, how you get to the
store does not matter: you could walk, drive or bike.
Plans and planning are intimately related to perceived affordances. In fact, perceived affordances are the basis for
planning. The current situation must contain an affordance
predicting one could go buy milk, as otherwise one would
not plan for it. Similarly, someone will only consider driving
to the store, at a different level of affordances, if that person
actually has access to a car, and if his or her encoding of the
situation contains the perceived affordance of driving. Perceived affordances are thus not the elements of a plan, but at
each step they are the possible choices a planner faces when
making decisions. Thus a planner must maintain sets of perceived affordances to perform its planning, and a hierarchical
planner maintains hierarchical trees of perceived affordances.

Parsing for Plan Recognition
Our implemented representation of perceived affordances is
based on context free parsing. Context free parsing recovers
hierarchical structures from a sequence of non-hierarchical
observations, so it is natural that context free grammars, and
especially PCFGs have been suggested as ideal paradigms for
performing hierarchical plan recognition (Bobick and Ivanov,
1998; Pynadath and Wellman, 2000), a suggestion that originally dates back at least to Miller et al. (1960). In this case,
the symbols in the terminal string correspond to observed
events in a temporal sequence, and the grammar specifies possible higher level event structures. The simplified example
depicted here is based on the studies that will be described in
the next section. The example involves two players, Roirry
(prefix ’R’) and Isania (prefix ’I’), that engage in the short
sequence of events depicted in Fig. 1. Isania pulls a lever to
open a door, and Roirry goes through the door and fetches a
key from a chest in the next room. A context free grammar
parser produces the parse tree shown in the upper part of Figure 1 given the input symbol sequence depicted in that figure
and the grammar in Table 1.

Language Grounding
The linguistic parsing step uses the same Earley parser as described earlier, this time parsing a string of words. Whenever
the parser produces a complete state, it attempts to ground
the constituent just produced in terms of ABCs. For this purpose, constituents can be associated with concept definitions.
A concept definition takes the form of a nested function call
expressing how the current set of perceived affordances is to
be filtered to arrive at the ABC for this constituent. Every
lexical item can be associated with one or more non-nested
function calls. Such a call includes the name of the filtering
function to apply to the set of affordances, and the argument
positions used in the function call. Upon completion of a
grammatical rule, the parser attempts to form a valid nested
function call from the call present in the tail of the rule. Figure 2 shows a simple parse tree with associated filter functions. This method of incremental composition driven by language syntax is akin to other work that associates grammatical rules with lambda calculus expressions (Schuler, 2003)
and our own work that performs compositional grounding according to explicit composition rules in the grammar (Gorniak and Roy, 2004).
An utterance occurs at a specific point in time, and at
that time the plan recognition Earley parsers will have a particular set of current and past Earley states under consideration. To interpret a concept definition, the nested func-

Table 1: Sample Plan Recognition Grammar Fragment
R RETRIEVE KEY → R ROOM 1 TO ROOM 2
R OPEN CHEST R TAKE KEY
R RETRIEVE KEY → R ROOM 1 TO ROOM 2
R OPEN CHEST R TAKE KEY
R ROOM 1 TO ROOM 2 → I MAKE DOOR PASSABLE
R ROOMCHANGE ROOM 1 TO ROOM 2
R ROOMCHANGE ROOM 1 TO ROOM 2 →
R THROUGH DOOR R ENTER ROOM 2
I MAKE DOOR PASSABLE → I PULL LEVER
O OPEN DOOR
I MAKE DOOR PASSABLE → I BREAK DOOR
I MAKE DOOR PASSABLE → I UNLOCK DOOR
I OPEN DOOR
R OPEN CHEST → R UNLOCK CHEST R LIFT LID
R OPEN CHEST → R BREAK CHEST

As we aim to use the internal states of a plan recognizer to
represent a set of affordances, we need to be careful to select
an algorithm that does predict all possible interactions at all
levels at any given point in time, but that uses the symbols
observed to constrain its search. The ideal candidate for an
efficient parser along these lines is an Earley parser, which
281

I PUL LEVER OOPEN DOORRTHROUGHDOORRENTER ROOM2RUNLOCK CHEST RLIFT LID RTAKEKEY
I PUL LEVER OOPEN DOORRTHROUGHDOORRENTER ROOM2RUNLOCK CHEST RLIFT LID RTAKEKEY
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2RUNLOCK CHEST RLIFT LID RTAKE KEY

R_RETRIEVE_KEY
R_ROOM_1_TO_ROOM_2

IPULLLEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNLOCKCHEST RLIFTLID RTAKEKEY
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2
→ RROOM1TOROOM2ROPENCHESTRTAKEKEY RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2
RRETRIEVEKEY
IMAKEDOORPAS ABLE → IPULL LEVER OOPEN DOOR
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
IMAKEDOORPAS ABLE → IBREAKDOOR
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2
IMAKEDOORPAS ABLE → IUNLOCKDOORIOPEN DOOR
IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR
ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID
IMAKEDOORPASSABLE → IBREAKDOOR
ROPEN CHEST
→ RBREAKCHEST
IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
R_OPEN_CHEST
ROPENCHEST
→ RUNLOCKCHESTRLIFTLID
ROPENCHEST
→ RBREAKCHEST

→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2
IMAKEDOORPAS ABLE → IPULL LEVER OOPEN DOOR
IMAKEDOORPAS ABLE → IBREAKDOOR
IMAKEDOORPAS ABLE → IUNLOCKDOORIOPEN DOOR
ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID
ROPEN CHEST
→ RBREAKCHEST

→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2RUNLOCK CHEST RLIFT LID RTAKE KEY
IMAKEDOORPAS ABLE → IBREAKDOOR
I_MAKE_DOOR_PASSABLE
R_ROOMCHANGE_ROOM_1_TO_ROOM_2
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY
RRETRIEVEKEY
IMAKEDOORPAS ABLE → IUNLOCK DOORIOPEN DOOR
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY
RRETRIEVEKEY
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2 R UNLOCK CHEST RLIFT LID RTAKE KEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2
ROPEN CHEST
→ RBREAKCHEST
0: 0 IMAKEDOORPAS ABLE → .IPULL LEVER OOPEN DOOR
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR
0: 0 IMAKEDOORPAS ABLE → .IBREAKDOOR
0: 0 IMAKEDOORPAS ABLE → .IPULL LEVER OOPEN DOOR
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2
IMAKEDOORPASSABLE → IBREAKDOOR
0: 0 IMAKEDOORPAS ABLE → .IUNLOCKDOORIOPEN DOOR
0: 0 IMAKEDOORPAS ABLE → .IBREAKDOOR
IMAKEDOORP
A
S
A
BL
E
→
IP
U
L
L
E
V
E
R
OOP
E
N
DOOR
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR
→ .RROOM1TOROOM2ROPEN CHEST RTAKEKEY
0: 0 RRETRIEVEKEY
0: 0 IMAKEDOORPAS ABLE → .IUNLOCKDOORIOPEN DOOR
0: 0 IMAKEDOORPASSABLE → .IPULLLEVEROOPENDOOR
IMAKEDOORP
A
S
A
BL
E
→
IBRE
A
KDOOR
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
ROPENCHEST
→ RUNLOCKCHEST RLIFTLID
IMAKEDOORPASSABLE → IBREAKDOOR
0
:
IMAKEDOORP
A
S
A
B
L
E
→
.
I
P
U
L
L
E
V
E
R
OOP
E
N
DOOR
0: 0 RROOM1TOROOM2 → .IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2
T
RI
E
V
EKE
Y
→
.RROOM1TOROOM2ROPE
N
CHE
S
T
RT
A
KEKE
Y
0:
RRE
0:
IMAKEDOORPASSABLE
→
.IBREAKDOOR
0
0
0
IMAKEDOORPAS ABLE → IUNLOCKDOORIOPEN DOOR
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
ROPENCHES
T
→
RBREAKCHES
T
IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
0 : 0 IMAKEDOORPAS ABLE → . I BREAKDOOR
0: 0 RROOM1TOROOM2 → .IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2 1: 0 IMAKEDOORPAS ABLE → IPULL LEVER . O OPEN DOOR
0: 0 IMAKEDOORPASSABLE → .IUNLOCKDOORIOPENDOOR
ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID
IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR
0 : 0 IMAKEDOORPAS ABLE → . I UNLOCK DOORIOPEN DOOR
2: 0 IMAKEDOORPAS ABLE → IPULL LEVER OOPEN DOOR.
→ .RROOM1TOROOM2ROPENCHESTRTAKEKEY 1: 0 IMAKEDOORPAS ABLE → IPULL LEVER . O OPEN DOOR
0: 0 RRETRIEVEKEY
ROPENCHEST
→ RUNLOCKCHEST RLIFTLID
ROPEN CHEST
→ RBREAKCHEST
IMAKEDOORPAS ABLE → IBREAKDOOR
→ . R ROOM1TO ROOM2ROPEN CHEST RTAKEKEY
0 : 0 RRETRIEVEKEY
2: 0 RROOM1TOROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TOROOM2
2: 0 IMAKEDOORPAS ABLE → IPULL LEVER OOPEN DOOR.
0: 0 RROOM1TOROOM2
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
ROPENCHEST
→ RBREAKCHEST
IMAKEDOORPAS ABLE → IUNLOCK DOORIOPEN DOOR
0 : 0 RROOM1TO ROOM2 → . I MAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
2: 0 RROOM1TOROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TOROOM2 2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTER ROOM2
1: 0 IMAKEDOORPASSABLE → IPULLLEVER.OOPENDOOR
ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID
0: 0 IMAKEDOORPASSABLE → .IPULLLEVEROOPENDOOR
1 : 0 IMAKEDOORPAS ABLE → IPUL LEVER . O OPEN DOOR
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR. R ENTER ROOM2
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTER ROOM2
2: 0 IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR.
ROPEN CHEST
→ RBREAKCHEST
0: 0 IMAKEDOORPASSABLE → .IBREAKDOOR
2 : 0 IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR.
4: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2.
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR. R ENTER ROOM2
2: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2
0 : 0 IMAKEDOORPAS ABLE → .IPUL LEVER OOPEN DOOR
0: 0 IMAKEDOORPASSABLE → .IUNLOCKDOORIOPENDOOR
2 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TO ROOM2
4: 0 RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2.
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2 4: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2.
0 : 0 IMAKEDOORPAS ABLE → .IBREAKDOOR R_THROUGH_DOOR
I_PULL_LEVER
O_OPEN_DOOR
R_ENTER_ROOM_2
R_LIFT_LID
→ .RROOM1TOROOM2ROPENCHES
T RTAKEKEY
0: 0 RRETRIEVEKEY
2 : 2 RROOMCHANGEROOM1TO ROOM2 → . R THROUGHDOORRENTERR_UNLOCK_CHEST
ROOM2
→ RROOM1TOROOM2.ROPEN CHEST RTAKEKEY
4: 0 RROOM1TOROOM2 → IMAKEDOORPAS AR_TAKE_KEY
BLE RROOMCHANGEROOM1TOROOM2. 4: 0 RRETRIEVEKEY
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
0: 0 IMAKEDOORPASSABLE → .IPULLLEVEROOPENDOOR
0 : 0 IMAKEDOORPAS ABLE → .IUNLOCKDOORIOPEN DOOR
0:
RROOM1TOROOM2
→
.IMAKEDOORPAS
S
A
BLERROOMCHANGEROOM1TOROOM2
RR
O
OMC
H
ANGER
O
OM1T
O
R
O
OM2
→
RT
H
R
O
UGHDOOR.
R
E
N
T
E
R
R
O
OM2
3
:
4:
→ .RUNLOCKCHEST RLIFT LID
RRE
T
RI
E
V
EKE
Y
→
RROOM1TOROOM2.ROPE
N
CHE
S
T
RT
A
KEKE
Y
4:
4:
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRENTERROOM2.
0
2
4 ROPEN CHEST
0
2
→ .RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
0 : 0 RRETRIEVEKEY
0: 0 IMAKEDOORPASSABLE → .IBREAKDOOR
0 : 0 IMAKEDOORPAS ABLE → . I PUL LEVER OOPEN DOOR
1: 0 IMAKEDOORPASSABLE → IPULLLEVER.OOPENDOOR
4 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
4: 4 ROPEN CHEST
→ .RBREAKCHEST
4: 4 ROPEN CHEST
→ .RUNLOCKCHEST RLIFT LID
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
0 : 0 RROOM1TO ROOM2 → .IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
0:
IMAKEDOORPAS
S
A
BLE
→
.IUNLOCKDOORIOPENDOOR
0
0 : 0 IMAKEDOORPAS ABLE → . I BREAKDOOR
2: 0 IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR.
4 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
5: 4 ROPEN CHEST
→ RUNLOCKCHEST . R LIFT LID
→ .RBREAKCHEST
→ RROOM1TOROOM2.ROPENCHESTRTAKEKEY 4: 4 ROPEN CHEST
4: 0 RRETRIEVEKEY
1 : 0 IMAKEDOORPAS ABLE → IPUL LEVER . O OPEN DOOR
→ .RROOM1TOROOM2ROPENCHEST RTAKEKEY
0: 0 RRETRIEVEKEY
0 : 0 IMAKEDOORPAS ABLE → . I UNLOCK DOORIOPEN DOOR
2: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2
→ RROOM1TO ROOM2. R OPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
6: 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
5: 4 ROPEN CHEST
→ RUNLOCKCHEST . R LIFT LID
4: 4 ROPENCHEST
→ .RUNLOCKCHESTRLIFTLID
2 : 0 IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR.
0: 0 RROOM1TOROOM2
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2 2: 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TO ROOM2
→ . R ROOM1TO ROOM2ROPEN CHEST RTAKEKEY
0 : 0 RRETRIEVEKEY
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2
4 : 4 ROPEN CHEST
→ . R UNLOCK CHEST RLIFT LID
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST . R TAKEKEY
6: 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
4: 4 ROPENCHEST
→ .RBREAKCHEST
0 : 0 RROOM1TO ROOM2 → . I MAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
4 : 4 ROPEN CHEST
→ . R BREAKCHEST
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY .
1: 0 IMAKEDOORPASSABLE → IPULLLEVER.OOPENDOOR
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST . R TAKEKEY
5: 4 ROPENCHEST
→ RUNLOCKCHEST.RLIFTLID
2 : 2 RROOMCHANGEROOM1TO ROOM2 → .RTHROUGHDOORRENTER ROOM2
1 : 0 IMAKEDOORPAS ABLE → IPUL LEVER . O OPEN DOOR
4:
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRENTERROOM2.
ROP
5
:
E
N
C
H
E
S
T
→
RUNL
O
C
K
C
H
E
S
T
.
R
L
I
F
T
L
I
D
7:
RRE
T
RI
E
V
EKE
Y
→
RROOM1TOROOM2ROPE
N
CHE
S
T
RT
A
KEKE
Y
.
6: 4 ROPENCHEST
→ RUNLOCKCHESTRLIFTLID .
2
4
3 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOOR. R ENTER ROOM2
0
2: 0 IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR.
2 : 0 IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR.
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
6 : 4 ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID .
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST.RTAKEKEY
2: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2 4: 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
2 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TO ROOM2
→ RROOM1TOROOM2.ROPENCHEST RTAKEKEY
4: 0 RRETRIEVEKEY
6 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST . R TAKEKEY
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHESTRTAKEKEY.
4 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2
2 : 2 RROOMCHANGEROOM1TO ROOM2 → . R THROUGHDOORRENTER ROOM2
4: 4 ROPENCHEST
→ .RUNLOCKCHEST RLIFTLID
7 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
→ RROOM1TO ROOM2.ROPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
3 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOOR. R ENTER ROOM2
4: 4 ROPENCHEST
→ .RBREAKCHEST
4 : 4 ROPEN CHEST
→ .RUNLOCKCHEST RLIFT LID
4: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2.
4 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
5: 4 ROPENCHEST
→ RUNLOCKCHEST .RLIFTLID
4 : 4 ROPEN CHEST
→ .RBREAKCHEST
4 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
6: 4 ROPENCHEST
→ RUNLOCKCHEST RLIFTLID .
→ RUNLOCKCHEST . R LIFT LID
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2. 5: 4 ROPEN CHEST
6 : 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
→ RROOM1TO ROOM2. R OPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST .RTAKEKEY
→ RROOM1TOROOM2.ROPENCHEST RTAKEKEY
4: 0 RRETRIEVEKEY
6 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST . R TAKEKEY
4 : 4 ROPEN CHEST
→ . R UNLOCK CHEST RLIFT LID
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY.
4: 4 ROPENCHEST
→ .RUNLOCKCHEST RLIFTLID
7 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
4 : 4 ROPEN CHEST
→ . R BREAKCHEST
4: 4 ROPENCHEST
→ .RBREAKCHEST
5 : 4 ROPEN CHEST
→ RUNLOCK CHEST . R LIFT LID
ROPENCHES
5:
T
→
RUNLOCKCHES
T
.RLI
F
TLI
D
4
6 : 4 ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID .
6: 4 ROPENCHEST
→ RUNLOCKCHEST RLIFTLID .
6 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST . R TAKEKEY
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST .RTAKEKEY
7 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
IPULL LEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNLOCKCHEST RLIFT LID RTAKEKEY

IPULL LEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNLOCKCHEST RLIFT LID RTAKEKEY

Isania

Roirry

0

1

2

3

4

5

6

7

Figure 1: Sample Event Trace and Plan Parse Tree

tion call it represents is interpreted as an incremental filter on the full set of perceived affordances. Thus, for example, a noun like “gate” might select all interactions in7: RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY.
volving opening, unlocking,
breaking
and walking through
doors at all present and past points in time, whereas a verb
like “open” might filter these to only include the possible
and actual interactions of opening doors. This simple example is shown in Fig. 2. Fig. 3, on the other hand,
shows the filter expressions from this simple parse tree applied to the previous affordance example. In sequence, the selected affordances for select(DOOR), select(OP EN ) and
select(OP EN, select(DOOR)) are highlighted.

breakable
goal

unlockable

0

unlockable
unlockable
and
breakable
start
door

select(OPEN,select(DOOR))

lever

chest

VP
NP

Figure 4: The map of the module used in studies.

select(DOOR)

VB

DT

NN

"open"

"the"

"gate"

their instructions and goals by using typed text. To limit dialogue phenomena, which are not the focus of the study, one
of the players is randomly chosen in the beginning and forced
to only use the following phrases: “Yes”, “No”, “I Can’t”,
“Done”, “Now”, “What’s going on?”, “OK.” The other player
is free to use unrestricted language.
The study included 26 players who played in 13 dyads after
responding to ads on the bulletin boards on the Neverwinter
Nights website. Eleven of these dyads completed the puzzle
in times ranging from 25 minutes to one hour, whereas the
others gave up after one hour. Nine sessions served for development purposes, such as writing the affordance grammar
and training the linguistic parser, and a group of four sessions formed an unbiased evaluation set. We first annotated
the development data and built and trained the system, then
annotated the evaluation data and tested the implementation
on this previously unseen data.
Events presented to the plan recognizer were at the level
of opening a door, walking into the next room or activating a
lever. The recognizer used a grammar of about 6500 probabilistic rules that were automatically generated from a handcoded grammar of about 90 meta-rules capturing the structure
of the puzzle as shown in Figure 4. The current evaluation focuses on directives because their effect on the second human
player is relatively easy to measure. We annotated 302 utterances in the development sessions and 69 utterances in the
testing sessions as directives, and all results shown here are
from these sets of utterances. The language parser uses 13
different affordance filter functions, including ones capturing

select(DOOR)

select(OPEN)

select(DOOR)

select(OPEN)

Figure 2: Simple parse tree example and affordance filters

Studies and Results
We have evaluated our implementation of the ABC theory
by employing it to interpret situated language recorded from
human-human communication during co-operative game
play. To do so, it is not only necessary to record and analyse human language, but also to apply the machinery introduced in the last section to model the situation in which the
language occurs. Here, we turn to multi-user graphical online
role playing games to provide a rich and easily sensed world
to support and capture human interaction.
We describe a set of studies using a commercial game,
Neverwinter Nights, that includes an editor allowing the creation of custom game worlds. Fig. 4 shows the map used
for the study presented here. Dependencies between objects
in the map are indicated with dotted arrows (for example, an
arrow links and lever that opens a door, and any chest containing a key for another chest or a door). The only objective
of the puzzle is to reach the goal indicated on the map. When
the two players start the puzzle, they only know that there is
a goal they need to step on somewhere in the module. This
puzzle is designed for players to separate and communicate
282

I PUL LEVER OOPEN DOORRTHROUGHDOORRENTER ROOM2RUNLOCK CHEST RLIFT LID RTAKEKEY

I PUL LEVER OOPEN DOORRTHROUGHDOORRENTER ROOM2RUNLOCK CHEST RLIFT LID RTAKEKEY
IPULLLEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNLOCKCHEST RLIFTLID RTAKEKEY

→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2
RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2
ABLE HROUGHDOORRE→ IPULNTERLRLOEOM2RU
VER OOPENLOCNKDOORCHEST RLIFT LID RTAKEKEY
→ RROOM1TOROOM2ROPENCHESTRTAKEKEY RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2
RRETRIEVEKEY
I PIMAKEDOORP
UL LEVER OOPEANSDOORRT
R_RETRIEVE_KEY RRETRIEVEKEY → RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
IMAKEDOORPAS ABLE → IBREAKDOOR
ABLE HROUGHDOORRE→ IPULNTERLRLOEOM2RU
VER OOPENLOCNKDOORCHEST RLIFT LID RTAKEKEY
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
I PIMAKEDOORP
UL LEVER OOPEANSDOORRT
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
IMAKEDOORPAS ABLE → IUNLOCKDOORIOPEN DOOR
IMAKEDOORPAS ABLE → IBREAKDOOR
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2
IPULL LEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNLOCKCHEST RLIFT LID RTAKEKEY
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
ROPE
N
CHE
S
T
→
RUNL
O
CKCHE
ST RLIFT LID
IMAKEDOORP
A
S
A
BL
E
→
IUNL
O
CKDOORIOPE
N
DOOR
IMAKEDOORPASSABLE
→
IPULLLEVEROOPENDOOR
IPULLLEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNLOCKCHEST RLIFTLID RTAKEKEY
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
IPUL LEVER OOPEN DOORRTHROUGHDOORRENTER ROOM2RUNLOCKCHEST RLIFT LID RTAKEKEY
ROPEN CHEST
→ RBREAKCHEST
ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID
IMAKEDOORPASSABLE → IBREAKDOOR
I PIMAKEDOORP
UL LEVER OOPEANSDAOBRLERTHROUGH DO R→REIPNTUELR RLOEVME2RUR OOPNLOECNKDOORCHEST RLIFT LID RTAKE KEY
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2RUNLOCK CHEST RLIFT LID RTAKE KEY
RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
IMAKEDOORPAS ABLE → IBREAKDOOR
ROPEN CHEST
→ RBREAKCHEST
IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRE
NTER ROOM2
RROOM1TOROOM2
→
IMAKEDOORP
A
S
A
BL
E
RROOMCHANGEROOM1TOROOM2
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY
RRETRIEVEKEY
IMAKEDOORPAS ABLE → IUNLOCK DOORIOPEN DOOR
ROPENCHEST
→ RUNLOCKCHESTRLIFTLID
ABLE HROUGHDOORRE→ IPULNTERLRLOEOM2RU
VER OOPENLOCNKDOORCHEST RLIFT LID RTAKEKEY
→ RROOM1TOROOM2ROPENCHESTRTAKEKEY RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2
RRETRIEVEKEY
R_ROOM_1_TO_ROOM_2
I PIMAKEDOORP
UL LEVER OOPEANSDOORRT
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID
ROPENCHEST
→ RBREAKCHEST
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY
RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
IMAKEDOORPAS ABLE → IBREAKDOOR
ABLE HROUGHDOORRE→ IPULNTERLRLOEOM2RU
VER OOPENLOCNKDOORCHEST RLIFT LID RTAKEKEY
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2 R UNLOCK CHEST RLIFT LID RTAKE KEY
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
I PIMAKEDOORP
UL LEVER OOPEANSDOORRT
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2
ROPEN CHEST
→ RBREAKCHEST
0:
IMAKEDOORP
A
S
A
BL
E
→
.IPUL
L
L
E
V
E
R
OOPE
0
RR
O
OM1T
O
R
O
OM2
→
IMAKEDOORP
A
S
A
B
L
E
RR
O
OMC
H
ANGER
O
OM1T
O
R
O
OM2
IMAKEDOORP
A
S
A
BL
E
→
IUNL
O
CKDOORIOPE
N
DOORN DOOR
IMAKEDOORP
A
S
A
BL
E
→
IBRE
A
KDOOR
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
SABLE → IPULLLEVEROOPENDOOR
IPULIMAKEDOORPAS
L LEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNL
OCKCHEST RLIFT LID RTAKEKEY
0:ROPE0 IMAKEDOORP
L LEVER OOPEN DOORN DOOR
0 IMAKEDOORP
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
N CHEST AS ABLE → RUNL→ .IBREOCKCHEAKDOORST RLIFT LID
AS AABLS EABLE → IUNL→ .IPULOCKDOORIOPE
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
IMAKEDOORPASSABLE → IPULLLEVEROOPENDOORT RLIFTLID RTAKEKEY 0:IMAKEDOORP
IPULLLEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNLOCKCHES
IMAKEDOORPASSABLE → IBREAKDOOR
TRIEVEKEY AS ABLE → RROOM1TOROOM2ROPE
N CHEST RTAKEKEY
IPRROOMCHANGEROOM1TOROOM2
UL LEVER OOPEN DOORRTHROUGHDOORRE→ RTHROUGHDOORRENTERROOM2
NTER ROOM2RUNLOCKCHEST RLIFT LID RTAKEKEY
0:RREROPE0 IMAKEDOORP
0:ROPE0 IMAKEDOORP
N CHEST
→ RBRE→ .IUNLAKCHEOCKDOORIOPE
ST N DOOR
N CHEST AS ABLE → RUNL→ .IBREOCKCHEAKDOORST RLIFT LID
IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR
IMAKEDOORPASSABLE → IBREAKDOOR
I PIMAKEDOORP
UL LEVER OOPEANSDAOBRLERTHROUGH DO R→REIPNTUELR RLOEVME2RUR OOPNLOECNKDOORCHEST RLIFT LID RTAKE KEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2RUNLOCK CHEST RLIFT LID RTAKE KEY
RROOM1TOROOM2
→
IMAKEDOORP
A
S
A
BL
E
RROOMCHANGEROOM1TOROOM2
T
RI
E
V
EKE
Y
→
RROOM1TOROOM2ROPE
N
CHE
S
T
RT
A
KEKE
Y
RRE
→ .RROOM1TOROOM2ROPE
N CHEST RTAKEKEY
0: 0 RRETRIEVEKEY
0:ROPE0 IMAKEDOORP
0:IMAKEDOORPASSABLE
→ .IPULLLEVEROOPENDOOR
IMAKEDOORPAS ABLE → IBREAKDOOR
N CHEST AS ABLE → RBRE→ .IUNLAKCHEOCKDOORIOPE
ST N DOOR
0 IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
IMAKEDOORPAS ABLE → IBREAKDOOR
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
ROPENCHEST
→ RUNLOCKCHEST RLIFTLID
→ RTHROUGHDOORRE
→ IMAKEDOORP
AS ABLE RROOMCHANGEROOM1TOROOM2
IMAKEDOORPASSABLE → IBREAKDOOR
0IMAKEDOORP
: 0 IMAKEDOORPAS AABSLEABLE → IUNL→ . OICPKULDOORIOP
LEVER OOPEN DOOREN DOOR
0:RROOMCHANGEROOM1TOROOM2
→ .IMAKEDOORPANSTEABLR ROOM2
E RROOMCHANGEROOM1TOROOM2
→ .RROOM1TOROOM2ROPE
N CHEST RTAKEKEY
0:RROOM1TOROOM2
0:ROPENCHEST
→ .IBREAKDOOR FTLID
0 RROOM1TOROOM2
0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY
RRETRIEVEKEY
I_MAKE_DOOR_PASSABLE
R_ROOMCHANGE_ROOM_1_TO_ROOM_2
R_OPEN_CHEST
0 IMAKEDOORPASSABLE
IMAKEDOORPAS ABLE → IUNLOCKDOORIOPEN DOOR
→ RUNLOCKCHESTRLI
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
ROPENCHES
T
→
RBREAKCHES
T
AS ABLE → IPUL→ IPULL LEVLELREVOOPEER . ONOPEDOORN DOOR
→ RTHROUGHDOORRE
EVEKEY
→ RROOM1TOROOM2ROPENCHESTRTAKEKEY
IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
0ROP: 0 IMAKEDOORP
1:IMAKEDOORP
0:RROOMCHANGEROOM1TOROOM2
→ .IMAKEDOORPANSTEABLR ROOM2
E RROOMCHANGEROOM1TOROOM2
0:RRETRI
→ .IUNLOCKDOORIOPENDOOR
0 IMAKEDOORPAS ABLE
0 RROOM1TOROOM2
ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID
RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
EN CHEST AS ABLE → RUNL→ . IOBCRKECAHKDOOREST RLIFT LID
0 IMAKEDOORPASSABLE → RBREAKCHEST
ROPENCHEST
→→ RROOM1TOROOM2ROPENCHES
RRETRI
TRIEVEKEY AS ABLE → RR→ O.OM1TI UNLOOCRKODOORIOP
OM2ROPEENN DOORCHEST RTAKEKEY
AS ABLE → IBRE→ IPULAKDOORL LEVER OOPEN DOOR.
AS ABLE → IPUL→ IPULL LEVLELREVOOPEER . ONOPEDOORN DOOR
I PIMAKEDOORP
UL LEVER OOPEANSDAOBRLERTHROUGH DO R→REIPNTUELR RLOEVME2RROOPUNLOECNKDOORCHEST RLIFT LID RTAKE KEY
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
→→ RROOM1T
RREROPTENRIECHEVEKEST Y
0RREROP: 0 IMAKEDOORP
2:IMAKEDOORP
→ .RROOM1TOROOM2ROPENCHESTRTAKEKEY 1:IMAKEDOORP
0:RROOM1TOROOM2
0 IMAKEDOORPAS ABLE
0 IMAKEDOORPAS ABLE
ROPENCHESEVEKEYT
RUNLOCKCHEST RLIFTLID T RTAKEKEY
RBREAKCHEO SROOM2ROP
T EN CHEST RTAKEKEY
RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2
E
N
C
H
E
S
T
→
RB
R
E
A
KC
H
E
S
T
0 RRETRIEVEKEY
0:IMAKEDOORP
IMAKEDOORPAS AABLS EABLE → IUNL→ .IPULOCKDOORIOPE
L LEVER OOPEN DOOR
IMAKEDOORPAS ABLE → IBREAKDOOR
E RROOMCENHANGER
AS ABLE → IBRE→ IPULAKDOORL LEVER OOPEN DOOR.
→ RTHROUGHDOORRENTERROOM2
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
RROOM1TOROOM2
→→ IMAKEDOORPAS
→ . R ROOM1TASOARBOLOM2ROP
CHEST RTOOM1TAKEKEO RYOOM2
0RR: 0ORREOM1TTROIERVOEKEOM2Y → IMAKEDOORP
2: 00 RROOM1TOROOM2
→ IMAKEDOORPASNADOORBLE . R ROOMCHANGEROOM1TOROOM2
2:IMAKEDOORP
0:RROOMCHANGEROOM1TOROOM2
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
0 IMAKEDOORPAS ABLE
SABLE → IPULLLEVEROOPENDOOR
0 RROOM1TOROOM2
ROPENCHEST
RBREAKCHEST SABLERROOMCHANGEROOM1TOROOM2
IPULIMAKEDOORPAS
L LEVEROOPENDOORRTHROUGHDOORRENTERROOM2RUNL
OCKCHEST RLIFT LID RTAKEKEY
0:ROPE0 IMAKEDOORP
0:IMAKEDOORP
IMAKEDOORPAS AABLS EABLE → IUNL→ .IPULOCKDOORIOPE
L LEVER OOPEN DOOR
IMAKEDOORPAS ABLE → IUNLOCK DOORIOPEN DOOR
UGHDOORREANSTAEBRLREORROM2OOMCHANGEROOM1TO ROOM2
N CHEST AS ABLE → RUNL→→ .IBRE
OCKCHEAKDOORST RLIFT LIDNTER ROOM2
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
→ IPULLLEVEROOPENDOOR
0RR: 0ORROMCOOM1THANGERO ROOOM1TOM2 O ROOM2 → RT→ H.RIOMAKEDOORP
2: 2 RROOMCHANGEROOM1TOROOM2
.RTHROUGHDOORRE
2: 00 RROOM1TOROOM2
→ IMAKEDOORPASNADOORBLE . R ROOMCHANGEROOM1TOROOM2
1:IMAKEDOORPASSABLE
→ IPULLLEVER.OOPENDOOR
IMAKEDOORPASSABLE → IBREAKDOOR
0 IMAKEDOORPASSABLE
IPRROOMCHANGEROOM1TOROOM2
UL LEVER OOPEN DOORRTHROUGHDOORRE→ RTHROUGHDOORRENTERROOM2
NTER ROOM2RUNLOCKCHEST RLIFT LID RTAKEKEY
0: IMAKEDOORP
0:ROPE0 IMAKEDOORP
ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID
N CHEST AS ABLE → RBRE→→ .IUNL
AKCHEOCKDOORIOPE
ST R ENNTEDOORR ROOM2
N CHEST AS ABLE → RUNL→→ .IBRE
OCKCHEAKDOORST RLIFT LIDNTER ROOM2
IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR
→ IBREAKDOOR
0:IMAKEDOORPAS
→ .IPULLLEVEROOPENDOOR
1IMAKEDOORP
: 0 IMAKEDOORPAS AABSLEABLE → IP→ULIPLUELVELREVOOPER .EONOPDOOREN DOOR
RTHROUGHDOOR.
3:ROPE20 RROOMCHANGEROOM1TOROOM2
2: 2 RROOMCHANGEROOM1TOROOM2
.RTHROUGHDOORRE
→ IPULLLEVEROOPENDOOR.
2:IMAKEDOORPASSABLE
0 IMAKEDOORPAS
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY
RRETRIEVEKEY
SABLESABLE → IUNLOCKDOORIOPENDOOR
0 IMAKEDOORPASSABLE
IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2RUNLOCK CHEST RLIFT LID RTAKE KEY
→ .RROOM1TOROOM2ROPEN CHEST RTAKEKEY
0: 0 RRETRIEVEKEY
0:ROPE0 IMAKEDOORP
AS ABLE → RBRE→ .IUNLAKCHEOCKDOORIOPE
NR_TAKE_KEY
DOOR
ROPEN CHEST
→ RBREAKCHEST I_PULL_LEVER
0:IMAKEDOORPASSABLE
→ .IPULLLEVEROOPENDOOR
IMAKEDOORP
A
S
A
B
L
E
→
IB
R
E
A
KDOOR
N
CHE
S
T
S
T
0 IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
IMAKEDOORP
A
S
A
BL
E
→
IBRE
A
KDOOR
0:
IMAKEDOORPAS
S
A
BLE
→
.IBREAKDOOR
IMAKEDOORP
A
S
A
B
L
E
→
IP
U
L
L
E
V
E
R
OOP
E
N
DOOR.
2
:
O_OPEN_DOOR
R_THROUGH_DOOR
R_ENTER_ROOM_2
R_UNLOCK_CHEST
R_LIFT_LID
4:
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRE
NTER ROOM2.
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOOR.
R
E
N
TE
R
ROOM2
3:
2: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2
0 T
0
2
2
RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
ROPENCHES
→ RUNLOCKCHEST RLIFTLID
IMAKEDOORPASSABLE → IBREAKDOOR
0IMAKEDOORP
: 0 IMAKEDOORPAS AABLS EABLE → IUNL→ .IPOCKDOORIOP
UL LEVER OOPEN DOOREN DOOR
0IMAKEDOORP
: IMAKEDOORPAS ABLE → . OICPKULDOORIOP
LEVER OOPEN DOOREN DOOR
0: 0 RROOM1TOROOM2 → .IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2
→ .RROOM1TOROOM2ROPEN CHEST RTAKEKEY
0: RRETRIEVEKEY
0:ROPENCHEST
IMAKEDOORPASSABLE → .IBREAKDOOR FTLID
EVEKEY SABLE → RROOM1TOROOM2ROPENCHES
T RTAKEKEY
0:RRETRI
→ .IUNLOCKDOORIOPENDOOR
2 : 00 RROOM1TAOSRAOBOM2LE → IUNL→ IMAKEDOORP
AS ABLE . R ROOMCHANGEROOM1TO ROOM2
4: 0 RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2.
2: 02 RROOMCHANGEROOM1TOROOM2→ RUNLOCKCHESTRLI
→ .RTHROUGHDOORRENTERROOM2 4: 02 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2.
0 IMAKEDOORPAS
RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2
ROPENCHES
T
→ RBREAKCHES
T
0ROP: 0 IMAKEDOORP
IMAKEDOORPASSABLE → IUNLOCKDOORIOPENDOOR
0ROP: 0 IMAKEDOORP
AS ABLE → RUNL→ . IOBCRKECAHKDOOREST RLIFT LID
1:
IMAKEDOORP
A
S
A
BL
E
→
IPUL
L
L
E
VER . O OPEN DOOR
0:
RROOM1TOROOM2
→
.IMAKEDOORP
A
S
A
BL
E
RROOMCHANGEROOM1TOROOM2
0:
IMAKEDOORPASSABLE
→
.IUNLOCKDOORIOPENDOOR
0
0
EN CHEST AS ABLE → RUNL→ .IBREOCKCHEAKDOORST RLIFT LID
RROOM1TOROOM2
→
IMAKEDOORPAS
S
A
BLERROOMCHANGEROOM1TOROOM2
E
N
C
H
E
S
T
0
→ RBREAKCHEST
→ .RROOM1TOROOM2ROPENCHEST RTAKEKEY
0: 0 RRETRIEVEKEY
2 : 2 RROOMCHANGEROOM1TO ROOM2 → . R THROUGHDOORRENTER ROOM2
→ RROOM1TOROOM2.ROPEN CHEST RTAKEKEY
4: 0 RRETRIEVEKEY
4: 0 RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2.
3:ROPENCHEST
2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
0:RRETRI
IMAKEDOORPAS
→RUNLOCKCHES
.IPULLLEVEROOPENDOOR
0
:
IMAKEDOORP
A
S
A
BL
E
→
.IUNL
O
CKDOORIOP
E
N
DOOR
EVEKEYT SABLE →→ RROOM1TOROOM2ROPENCHES
T
RTAKEKEY
0ROPENCHES
I PIMAKEDOORP
UL LEVER OOPEANSDAOBRLERTHROUGH DO R→REIPNTUELR RLOEVME2RROOPUNLOECNKDOORCHEST RLIFT LID RTAKE KEY
0
T
R
I
E
V
EKE
Y
→
RROOM1T
O
ROOM2ROP
E
N
CHE
S
T
RT
A
KEKE
Y
RRE
0
:
IMAKEDOORP
A
S
A
B
L
E
→
.
I
UNL
O
C
K
DOORIOP
E
N
DOOR
IMAKEDOORP
A
S
A
BL
E
→
IPUL
L
L
E
V
E
R
OOPE
N
DOOR.
2:
1:
IMAKEDOORP
A
S
A
BL
E
→
IPUL
L
L
E
V
E
R
.
O
OPE
N
DOOR
→ .RROOM1TOROOM2ROPENCHESTRTAKEKEY 4: 0 RRETRIEVEKEY
0: 0 RRETRIEVEKEY
0
T RLIFTLID
ROPEN CHEST
→ RBREAKCHEST
→ RTHROUGHDOORRENTERROOM2
EST R ENTER ROOM2
0:RROOMCHANGEROOM1TOROOM2
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
3ROP: 20 RRENOCOMCHESTHANGEROOM1TO ROOM2→ RB→ RRTEAKCHROHUGHDOOR.
ROPEN CHEST AS ABLE → .IPUL
.RUNLLOLCKCHE
→ RROOM1TOROOM2.ROPEN CHEST RTAKEKEY
4: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2.
0 RROOM1TOROOM2
0
0:4: 40 IMAKEDOORP
EVER OOPEST RLNIFDOORT LID
IMAKEDOORPAS ABLE → IBREAKDOOR
VEKEY → IMAKEDOORP
→ .RROOM1TASOAROOM2ROP
EN CHEST RTAKEKEO ROOM2
Y
0RROOM1T
: 0 RRETROIEROOM2
0:RROOM1TOROOM2
→ .IBREAKDOOR
BLE RROOMCHANGEROOM1T
→ . R ROOM1TO ROOM2ROPEN CHEST RTAKEKEY
0 : 0 RRETRIEVEKEY
2: 0 RROOM1TOROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TOROOM2
2: 0 IMAKEDOORPAS ABLE → IPULL LEVER OOPEN DOOR.
0 IMAKEDOORPAS
0: 0 RROOM1TOROOM2
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
SABLE → IPULLLEVEROOPENDOOR
ROPENCHES
T SABLE →→ IMAKEDOORPAS
RBREAKCHES
T SABLERROOMCHANGEROOM1TOROOM2
0IMAKEDOORP
: 0 IMAKEDOORPAS AABSLEABLE → IUNL→ . OICPKULDOORIOP
LEVER OOPEN DOOREN DOOR
1:IMAKEDOORPAS
→ IPULLLEVER.OOPENDOOR
4 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
ROPEN CHEST AS ABLE → .IBRE
.RBREAKDOOR
KCHEST
ROPEN CHEST AS ABLE → .IPUL
.RUNLLOLCKCHE
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
0 IMAKEDOORPASSABLE
0:4: 04 IMAKEDOORP
0:4: 40 IMAKEDOORP
EVER OOPEST RLNIFDOORT LID
0RROOMCHANGEROOM1T
: 0 RROOM1TO ROOM2 O ROOM2 → RT→ H.IMAKEDOORP
E RROOMCHANGEROOM1TO ROOM2
ROUGHDOORREANSTAEBLR ROOM2
0 : RROOM1TO ROOM2 → . I MAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTER ROOM2
2: RROOM1TOROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TOROOM2
0:RROOMCHANGEROOM1TOROOM2
→ .IUNLOCKDOORIOPENDOOR
1: 0 IMAKEDOORPASSABLE → IPULLLEVER.OOPENDOOR
0 IMAKEDOORPASSABLE → RTHROUGHDOORRENTERROOM2
SABLE → IBREAKDOOR
0ROP: 0 IMAKEDOORP
→ IPULLLEVEROOPENDOOR.
2:IMAKEDOORPAS
4 : 00 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
ROPEN CHEST AS ABLE → .IUNL
RUNLOCKCHE
ST . R LIFNTDOORLID
ROPEN CHEST AS ABLE → .IBRE
.RBREAKDOOR
KCHEST
→ RROOM1TOROOM2.ROPENCHESTRTAKEKEY 0:4: 040 IMAKEDOORP
4: 0 RRETRIEVEKEY
0 IMAKEDOORPASSABLE
0:5: 4 IMAKEDOORP
CKDOORIOPE
EN CHEST AS ABLE → RUNL→ . IOBCRKECAHKDOOREST RLIFT LID
1IMAKEDOORP
: 0 IMAKEDOORPAS AABLS EABLE → IP→ULIPLUELVELREVOOPER .EONOPDOOREN DOOR
0:IMAKEDOORPAS
→ .IPULLLEVEROOPENDOOR
1 : 0 IMAKEDOORPAS ABLE → IPUL LEVER . O OPEN DOOR
3: 20 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR. R ENTER ROOM2
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTER ROOM2
2: 0 IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR.
0 IMAKEDOORPAS
TRIEVEKEY AS ABLE → RR→ O.OM1TI UNLOOCRKODOORIOP
OM2ROPEN CHEST RTAKEKEY
→ .RROOM1TOROOM2ROPENCHEST RTAKEKEY
0:IMAKEDOORPAS
SABLESABLE → IUNLOCKDOORIOPENDOOR
→ IPULLLEVEROOPENDOOR
0 RRETRIEVEKEYSABLE
0RREROP: 0 IMAKEDOORP
2:
RROOM1TOROOM2
→
IMAKEDOORPAS
S
A
BLE.RROOMCHANGEROOM1TOROOM2
RRE
T
R
I
E
V
EKE
Y
→
RR
O
OM1T
O
R
O
OM2.
R
OP
E
N
C
H
E
S
T
RT
A
KEKE
Y
4
:
6:
ROPE
N
CHE
S
T
→
RUNL
O
CKCHE
ST RLIFT LID .N CHEST RTAKEKEY
ROPE
5:
N
CHE
S
T
RUNL
O
CKCHE
S
T
.
R
L
I
F
T
L
I
D
4:
ROPENCHEST
→
.RUNLOCKCHESTRLI
F
TLI
D
0
0
4
4
T
RI
E
V
EKE
Y
.RROOM1TOROOM2ROPE
0:
RRE
0:
IMAKEDOORP
A
S
A
BL
E
→
.IUNL
CKDOORIOPE
N
DOOR
EN CHEST
→ RBREAKCHEST EN DOOR
UL LEVER OOPEN DOOR.
2IMAKEDOORP
: 0 IMAKEDOORPAS AABLS EABLE → IBRE→ IPAKDOOR
0: 40 IMAKEDOORPASSABLE
.IPULLLEVEROOPENDOOR
0: 0 IMAKEDOORPAS
→ .IBREAKDOORT RLIFTLID
2 : IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR.
4: 0 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2.
3: 20 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR. R ENTER ROOM2
2: RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2
E RROOMCENHANGER
T SABLE → RUNLOCKCHES
0:IMAKEDOORPAS
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
SABLE → IBREAKDOOR
→ . R ROOM1TASOARBOLOM2ROP
CHEST RTOOM1TAKEKEO RYOOM2
0RR: 0ORREOM1TTROIERVOEKEOM2Y → IMAKEDOORP
2:ROPENCHES
02IMAKEDOORP
:: 00 IMAKEDOORP
UL LEVER AOOPESNADOOREBLNEDOOR. R ROOMCHANGEROOM1TO ROOM2
40 : 400 ROPIMAKEDOORP
EN CHEST AS ABLE → . RI PUNLUL OLCEKVECRHEOOPST RLENIFDOORT LID
6:0: 002 RRERROOM1TOROOM2
TRIEVEKEY
→ .IMAKEDOORP
RROOM1TOROOM2ROPE
N CHEST . R TAKEKEY
6:0: 04 ROPERRETNRIECHEVEKEST Y
→ RUNL.RROOM1TOROOM2ROPE
OCKCHEST RLIFT LID .N CHEST RTAKEKEY
0 RROOM1TOROOM2
4:0: 004 ROPENCHEST
2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2
AS ABLE RROOMCHANGEROOM1TOROOM2
RROOM1TAOSROOM2
IMAKEDOORPASSABLE → .RBREAKCHEST
.IBREAKDOOR
AABLS EABLE → IUNL→→ .IPIMAKEDOORP
OCKDOORIOP
0:ROPENCHES
SABLE → RBREAKCHES
→ .IUNLOCKDOORIOPENDOOR
2 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TO ROOM2
4:
RROOM1TOROOM2
→
IMAKEDOORP
AS ABLE RROOMCHANGEROOM1TOROOM2.
4:
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRE
N
TE
R
ROOM2.
2:
RROOMCHANGEROOM1TOROOM2
→
.RTHROUGHDOORRENTERROOM2
0 IMAKEDOORPAS
0
2
UGHDOORREANSTAEBRLREORROM2OOMCHANGEROOM1TO ROOM2
T
T
2
0
:
IMAKEDOORP
A
S
A
BL
E
→
.IBRE
A
KDOOR
0RR: 0ORROMCOOM1THANGERO ROOOM1TOM2 O ROOM2 → RT→ H.RIOMAKEDOORP
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
ROPEN CHEST AS ABLE → . IRBREAKDOOR
KCHEST
RRETRIEVEKEYAS ABLE → IPULRROOM1TOROOM2ROPE
6:0: 00 RRERROOM1TOROOM2
TRIEVEKEY
RROOM1TOROOM2ROPE
N CHEST . R TAKEKEY
1:IMAKEDOORPAS
→ IPULLLEVER.OOPENDOOR
ROPENCHEST
RUNLOCKCHEST.RLIFTLID
SABLESABLE → IUNLOCKDOORIOPENDOOR
04 : 04 IMAKEDOORP
1:7: 00 IMAKEDOORP
L LEVER . O OPEN DOORN CHEST RTAKEKEY .
→ .IMAKEDOORP
AS ABLE RROOMCHANGEROOM1TOROOM2
2ROP: 02 RROOMCHANGEROOM1T
0 IMAKEDOORPAS
0:5: 04 IMAKEDOORPASSABLE
→ .IUNLOCKDOORIOPENDOOR
EN CHEST O ROOM2→ RUNL→ .RTOCKCHEHROUGHDOORRE
ST RLIFT LIDNTER ROOM2
E
VEKEY
→
.RROOM1TOROOM2ROPENCHES
T
RTAKEKEY
0:
RRETRI
2
:
RR
O
OMC
H
ANGER
O
OM1T
O
R
O
OM2
→
.
R
T
H
R
O
UGHDOORRE
N
T
E
R
R
O
OM2
RRE
T
RI
E
V
EKE
Y
→
RROOM1TOROOM2.ROPE
N CHEST RTAKEKEY
4:
4:
RROOM1TOROOM2
→
IMAKEDOORP
A
S
A
BL
E
RROOMCHANGEROOM1TOROOM2.
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOOR.RENTERROOM2
3:
0
2
0
0
IMAKEDOORP
A
S
A
B
L
E
→
IP
U
L
L
E
V
E
R
OOP
E
N
DOOR
2
0:2:ROPENCHES
→→ .IPULLLEVEROOPENDOOR
IMAKEDOORP
OCKDOORIOP
1 : 0 IMAKEDOORPAS ABLE → IPUL LEVER . O OPEN DOOR
4: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2.
ROPEN CHEST AS ABLE → .RUNLI UNLOCK CDOORIOP
HEST . R LEIFNTDOORLID
RRETRIEVEKEYAS ABLE → IPULRROOM1TOROOM2ROPE
0 IMAKEDOORPAS
ROPENCHEST
→ RUNLOCKCHESTRLI
FTLID .
05 : 04 IMAKEDOORP
2: 0 IMAKEDOORPAS ABLE → IPULL LEVER OOPEN DOOR.
1:7: 00 IMAKEDOORP
L LEVER . O OPEN DOORN CHEST RTAKEKEY .
RTAKCHEHROUGHDOOR.
30ROP:: 20 RROOMCHANGEROOM1T
IPULLLEVEROOPENDOOR.
EVEKEY
.RROOM1TOROOM2ROPENCHESTRTAKEKEY
0:6: 04 RRETRI
T SSAABLEBLE → RUNLOCKCHES
T RLIFTLID
EN CHEST AS ABLE O ROOM2→ RBRE→→ .IUNL
ST R EENNTDOORER ROOM2
0 IMAKEDOORPAS
0:
RROOM1TOROOM2
→
.IMAKEDOORPAS
S
A
BLERROOMCHANGEROOM1TOROOM2
RR
O
OMC
H
ANGER
O
OM1T
O
R
O
OM2
→
RT
H
R
O
UGHDOOR.
R
E
N
T
E
R
R
O
OM2
3
:
4:
ROPE
N
CHE
S
T
→
.RUNL
O
CKCHE
S
T
RL
I
F
T
L
I
D
RRE
T
RI
E
V
EKE
Y
→
RROOM1TOROOM2.ROPE
N
CHE
S
T
RT
A
KEKE
Y
4:
4:
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRENTERROOM2.
0
2
4
0
TRIEVEKEY O ROOM2 →→ RT.RROOM1T
O ROOM2ROPNTEREROOM2.
N CHEST RTAKEKEY
04 :: 02 RRERROOMCHANGEROOM1T
UL LEVER OOPEN DOOR.
2IMAKEDOORP
: 0 IMAKEDOORPAS AABSLEABLE → IB→REIPAKDOOR
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
→ RUNL. R ROOM1TCK CHOERSTOOM2ROP
RLIFT LIDE.N CHEST RTAKEKEY
0:2:ROPENCHES
→→ .IBREAKDOOR
6:0: 002 RRETRI
EVEKEY
RROOM1TOROOM2ROPENCHEST.RTAKEKEY 2: 0 IMAKEDOORPAS ABLE → IPULL LEVER OOPEN DOOR.
HROUGHDOORRE
06 : 04 RREROPTENRIECVHEKEEST Y
2: RROOM1TOROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TOROOM2
0 IMAKEDOORPAS
RROOM1TOROOM2
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
IMAKEDOORPAS
T SABLE → RBREAKCHES
T SABLE.RROOMCHANGEROOM1TOROOM2
0 RROOM1TOROOM2
0IMAKEDOORP
: IMAKEDOORPAS ABLE → . OICPKULDOORIOP
LEVER OOPEN DOOREN DOOR
1: 0 IMAKEDOORPASSABLE → IPULLLEVER.OOPENDOOR
4 : RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
4: 04 ROPEN CHEST
→ .RBREAKCHEST
4: ROPEN CHEST
→ .RUNLOCKCHEST RLIFT LID
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
04 :: 00 RROOM1T
RROOMCHANGEROOM1TOOROOM2.
ROOM2
2 : 00 RROOM1TAOSRAOBOM2LE → IUNL→ IMAKEDOORP
AS ABLE . R ROOMCHANGEROOM1TO ROOM2
→ RROOM1TOROOM2.ROPENCHEST RTAKEKEY
4: 0 RRETRIEVEKEY
60 : 002 RRERROTOM1TRIEVEKEO ROYOM2 → .RRI MAKEDOORP
OOM1TO ROOM2ROP
ENOCOMCHESTHANGER
. R TAKEKEOOM1TY O ROOM2
7: 00 IMAKEDOORPASSABLE
RRETRIEVEKEY
RROOM1TOROOM2ROPENCHESTRTAKEKEY. 2: 40 RROOM1TOROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TOROOM2
RROOM1TOO ROOM2
ROOM2 →→ .IMAKEDOORP
IMAKEDOORPAASSAABLBLEERROOMCHANGEROOM1T
A
S
A
B
L
E
RR
2:
RROOMCHANGEROOM1TOROOM2
→
.RTHROUGHDOORRE
N
TE
R
ROOM2
0:
IMAKEDOORPAS
S
A
BLE
→
.IUNLOCKDOORIOPENDOOR
1:
→
IPULLLEVER.OOPENDOOR
2
0
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2
0 : IMAKEDOORPAS ABLE → . I BREAKDOOREST RLIFT LID
2: 0 IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR.
4 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
5: 4 ROPEN CHEST
→ RUNLOCKCHEST . R LIFT LID
→ .RBREAKCHEST
→ RROOM1TOROOM2.ROPENCHESTRTAKEKEY 4: 4 ROPEN CHEST
4: 0 RRETRIEVEKEY
14 :: 00 IMAKEDOORP
UL LEVEORROOM2.ROP
. O OPEN DOOREN CHEST RTAKEKEY
2ROP: 02 RRENOCOMCHESTHANGEROOM1TO ROOM2→ RUNL→ . ROCTKHRCOHUGHDOORRE
NTER ROOM2
ROPENCHEST SABLE → .IPULLLEVEROOPENDOOR
.RUNLOCKCHEST RLIFTLID
RRETRIEVEKEYAS ABLE → IPRRUOLOM1TLEVEORR. OOM2ROP
RRETRIEVEKEYAS ABLE →→ IPRROOM1T
0:4: 40 IMAKEDOORPAS
17 : 00 IMAKEDOORP
OPEN DOOREN CHEST RTAKEKEY .
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR. R ENTER ROOM2
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTER ROOM2
2: 0 IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR.
.RROOM1TOROOM2ROPENCHEST RTAKEKEY
RRETRIEVEKEY
0 : IMAKEDOORPAS ABLE → . I UNLOECSKTDOORIOPEN DOOR
2: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2
→ RROOM1TO ROOM2. R OPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
6: 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
5: 4 ROPEN CHEST
→ RUNLOCKCHEST . R LIFT LID
4: 4 ROPENCHEST
→ .RUNLOCKCHESTRLIFTLID
→→ RTHROUGHDOOR.RENTERROOM2
3:0: 20 RROOMCHANGEROOM1TOROOM2
VER OOPSTERLN DOOR.IFT LID
24 :: 40 IMAKEDOORP
R ENTER ROOM2
3ROP: 20 RRENOCOMCHESTHANGEROOM1TO ROOM2→ RB→ RRTEAKCHROHUGHDOOR.
ROPENCHEST SABLE → .IBREAKDOOR
.RBREAKCHEST
ROPEN CHEST AS ABLE →→ IP.RUNLUL LOECKCHE
0:4: 04 IMAKEDOORPAS
2 : 0 IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR.
4: RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTER ROOM2.
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR. R ENTER ROOM2
2: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2
0:4: 0 RROOM1TOROOM2
→ .IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2
→ . R ROOM1TO ROOM2ROPEN CHEST RTAKEKEY
0 : 0 RRETRIEVEKEY
2: RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2
0 : IMAKEDOORPO ROOM2AS ABLE →→ .IPIMAKEDOORP
UL LEVER OOPEN DOOR
4 : 4 ROPEN CHEST
→ . R UNLOCK CHEST RLIFT LID
6: 02 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST . R TAKEKEY
6: 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
4: 4 ROPENCHEST
→ .RBREAKCHEST
4 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
ROPENCHEST SABLE → .IUNLOCKDOORIOPENDOOR
5: 420 IMAKEDOORPAS
RUNLOCKCHEST .RLIFTLID
2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2.
42 :: 400 ROPRROOM1T
EN CHEST
→ .RBREAKCHESATS ABLE . R ROOMCHANGEROOM1TO ROOM2
0:
2
:
RR
O
OM1T
O
R
O
OM2
→
IMAKEDOORP
A
S
A
B
L
E
.
R
R
O
OMC
H
ANGER
O
OM1T
O
R
O
OM2
4:
RROOM1TOROOM2
→
IMAKEDOORP
A
S
A
BL
E
RROOMCHANGEROOM1TOROOM2.
4:
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRE
N
TE
R
ROOM2.
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2 6: 2 RRETRIEVEKEY
0 : IMAKEDOORPAS ABLE O ROOM2 →→ .IBRE
AKDOOR NTER ROOM2
0 : RROOM1TO ROOM2 → . I MAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
4 : 04 ROPEN CHEST
→ . R BREAKCHEST
7: 00 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY .
→ RROOM1TOROOM2ROPEN CHEST . R TAKEKEY
IMAKEDOORPASSABLE →→ IMAKEDOORPAS
IPULLLEVER.OOPENDOOR
5: 4 ROPENCHEST
→ RUNLOCKCHEST.RLIFTLID
0
4 : 00 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
6:0: 04 ROPENCHES
→ RUNLOCKCHES
T RLIFTLID . T RTAKEKEY
52 :: 024 ROPRROOMCHANGEROOM1T
EN CHEST
→ RUNL.RTHOROUGHDOORRE
CKCHEST . R LIFT LID
4:1:0: 00 RROOM1TOROOM2
SABLERROOMCHANGEROOM1TOROOM2.
.RROOM1TOROOM2ROPENCHES
RRETRIEVEKEYT
2 : 2 RROOMCHANGEROOM1TO ROOM2 → . R THROUGHDOORRENTER ROOM2
→ RROOM1TOROOM2.ROPEN CHEST RTAKEKEY
4: 0 RRETRIEVEKEY
4: 0 RROOM1TOROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TOROOM2.
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
IMAKEDOORPASSSAABLEBLE →→ IPULLLEVEROOPENDOOR.
.IPULLLEVEROOPENDOOR
IMAKEDOORPAS ABLE O ROOM2 →→ .IUNL
OCKDOORIOPEN DOOR
1 : 0 IMAKEDOORPAS ABLE → IPUL LEVER . O OPEN DOOR
4: RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2.
5 : 4 ROPEN CHEST
→ RUNLOCK CHEST . R LIFT LID
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY .
6: 4 ROPENCHEST
→ RUNLOCKCHESTRLIFTLID .
306 ::: 204 RROOMCHANGEROOM1T
2:4: 00 IMAKEDOORPAS
ROPEN CHEST
→ RTRUNLHROUGHDOOR.
OCKCHEST RLRIFETNTLEIDR.ROOM2
→ RROOM1TO ROOM2. R OPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
6:0: 002 RRETRI
EVEKEY
RROOM1TOROOM2ROPENCHES
T .RTAKEKEY
RROOM1TOROOM2
→ .IMAKEDOORPAS
SABLERROOMCHANGEROOM1TOROOM2
3 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOOR. R ENTER ROOM2
4: 4 ROPEN CHEST
→ .RUNLOCKCHEST RLIFT LID
→ RROOM1TOROOM2.ROPEN CHEST RTAKEKEY
4: RRETRIEVEKEY
RRETRIEVEKEY SABLE →→ .IBREAKDOOR
RROOM1TOROOM2.ROPENCHEST RTAKEKEY
4: RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOORRENTERROOM2.
O ROOM2ROPEN CHEST RTAKEKEY
0 : RRETRIEVEKEY O ROOM2 →→ RT.RROOM1T
2 : 0 IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR.
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
6 : 4 ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID .
0:2: 00 IMAKEDOORPAS
6: 02 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST.RTAKEKEY 0
HROUGHDOORRE
64 :: 002 RRERROOMCHANGEROOM1T
TRIEVEKEY
→ RROOM1T
O ROOM2ROPNTERENROOM2.
CHEST . R TAKEKEY
→→ IMAKEDOORPAS
SARLIBLE.RROOMCHANGEROOM1TOROOM2
ROPEN CHEST AS ABLE → . IRPUNLUL OLCEKVECRHEOOPST RLENIFDOORT LID
RRETRIEVEKEY SABLE → IPULLLEVER.OOPENDOOR
RROOM1TOROOM2ROPENCHEST RTAKEKEY.
04 : 4 IMAKEDOORP
1:7: 00 IMAKEDOORPAS
4 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
4: 4 ROPEN CHEST
→ .RBREAKCHEST
4: 4 ROPEN CHEST
→ .RUNLOCKCHEST RLIFT LID
4: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
4:0: 40 RROOM1TOROOM2
ROPENCHES
T
.RUNLOCKCHES
T
F
TLI
D
0
:
RROOM1T
O
ROOM2
→
.IMAKEDOORP
A
S
A
BL
E
RROOMCHANGEROOM1T
O
ROOM2
2 : 00 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TO ROOM2
RRETRI
E
VEKEY
→
RROOM1TOROOM2.ROPENCHES
T
RTAKEKEY
4:
6
:
RRE
T
R
I
E
V
EKE
Y
→
RR
O
OM1T
O
R
O
OM2ROP
E
N
C
H
E
S
T
.
R
T
A
KEKE
Y
0
7:
RRETRI
E
VEKEY
→
RROOM1TOROOM2ROPENCHESTRTAKEKEY.
4
:
RROOM1T
O
ROOM2
→
IMAKEDOORP
A
S
A
BL
E
RROOMCHANGEROOM1T
O
ROOM2.
0
0
SABLE →→ .IUNLOCKDOORIOPENDOOR
0
7 : 00 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
ROPEN CHEST AS ABLE → . IRBREAKDOOR
KCHEST
2:4: 02 IMAKEDOORPAS
RROOMCHANGEROOM1TOROOM2
.RTHROUGHDOORRENTERROOM2
04 : 4 IMAKEDOORP
2: 0 IMAKEDOORPASSABLE → IPULLLEVEROOPENDOOR.
4 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
5: 4 ROPEN CHEST
→ RUNLOCKCHEST . R LIFT LID
4: 4 ROPEN CHEST
→ .RBREAKCHEST
RRETRI
E
VEKEY
→
RROOM1TOROOM2.ROPENCHESTRTAKEKEY
4:
0
1
:
IMAKEDOORP
A
S
A
BL
E
→
IP
U
L
L
E
V
E
R
.
O
OP
E
N
DOOR
ROPENCHES
T
→
.RBREAKCHES
T
0
2 : 02 RROOMCHANGEROOM1TO ROOM2 → . R THROUGHDOORRENTER ROOM2
4:
ROPENCHES
T
→
.RUNLOCKCHES
T
RLI
F
TLI
D
7
:
RRE
T
R
I
E
V
EKE
Y
→
RR
O
OM1T
O
R
O
OM2ROP
E
N
C
H
E
S
T
RT
A
KEKE
Y
.
4 RRETRIEVEKEY
→ RROOM1TO ROOM2.ROPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
4
0
.RROOM1TOROOM2ROPENCHEST RTAKEKEY
ROPEN CHEST AS ABLE → .RUNLI UNLOCK CDOORIOP
HEST . R LEIFNTDOORLID
05 : 4 IMAKEDOORP
2: 0 RROOM1TOROOM2
→ IMAKEDOORPASSABLE.RROOMCHANGEROOM1TOROOM2
→ RROOM1TO ROOM2. R OPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
6: 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
5: 4 ROPEN CHEST
→ RUNLOCKCHEST . R LIFT LID
4: 4 ROPENCHEST
→ .RUNLOCKCHESTRLIFTLID
→→→ RTHROUGHDOOR.RENTERROOM2
3:0:5: 20 RROOMCHANGEROOM1TOROOM2
VER OOPSTERLN DOOR.IFT LID
24 :: 40 IMAKEDOORP
3 : 20 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOOR. R ENTER ROOM2
4: 4 ROPENCHEST
→ .RBREAKCHEST
ROPENCHEST
RUNLOCKCHEST .RLISABLERROOMCHANGEROOM1TOROOM2
FTLID
ROPEN CHEST AS ABLE →→ IP.RUNLUL LOECKCHE
→ RUNL. R ROOM1TCK CHOERSTOOM2ROP
RLIFT LIDE.N CHEST RTAKEKEY
0:4: 04 RROOM1TOROOM2
→ .IMAKEDOORPAS
06 : 04 RREROPTENRIECVHEKEEST Y
2: 2 RROOMCHANGEROOM1TOROOM2 → .RTHROUGHDOORRENTERROOM2
4 : 4 ROPEN CHEST
→ . R UNLOCK CHEST RLIFT LID
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST . R TAKEKEY
6: 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
4: 4 ROPENCHEST
→ .RBREAKCHEST
24 :: 40 RROOM1T
RROOMCHANGEROOM1TOROOM2
RTHROUGHDOORRENTERROOM2.
4 : RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
5: 4 ROPENCHEST
→ RUNLOCKCHEST .RLIFTLID
2 ROPENCHES
ROPEN CHEOSTROOM2 →→ IMAKEDOORP
.RBREAKCHESATS ABLE . R ROOMCHANGEROOM1TO ROOM2
T SABLE →→→ IPULLLEVER.OOPENDOOR
RUNLOCKCHES
T RLIFTLID .
60 : 002 RRERROTOM1TRIEVEKEO ROYOM2 → .RRI MAKEDOORP
OOM1TO ROOM2ROP
. R TAKEKEOOM1TY O ROOM2
AS ABLE RRENOCOMCHESTHANGER
3: 2 RROOMCHANGEROOM1TOROOM2 → RTHROUGHDOOR.RENTERROOM2
4 : 4 ROPEN CHEST
→ . R BREAKCHEST
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY .
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST . R TAKEKEY
1:6: 40 IMAKEDOORPAS
5: 4 ROPENCHEST
→ RUNLOCKCHEST.RLIFTLID
4 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
6: 4 ROPENCHEST
→ RUNLOCKCHEST RLIFTLID .
52 :: 24 ROPRROOMCHANGEROOM1T
EN CHEST O ROOM2 →→ RUNL.RTHOROUGHDOORRE
CKCHEST . R LIFNTTLEIRDROOM2
RROOM1TOROOM2
→→ IMAKEDOORPAS
SABLERROOMCHANGEROOM1TOROOM2.
6:4:2: 00 RRETRI
E
VEKEY
RROOM1TOROOM2ROPENCHES
T
.RTAKEKEY
RRETRIEVEKEYAS ABLE → IPRRUOLOM1TLEVEORR. OOM2ROP
17 : 00 IMAKEDOORP
OPEN DOOREN CHEST RTAKEKEY .
4:
RROOMCHANGEROOM1TOROOM2
→
RTHROUGHDOORRENTERROOM2.
ROP
5
:
E
N
C
H
E
S
T
→
RUNL
O
C
K
C
H
E
S
T
.
R
L
I
F
T
L
I
D
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPEN CHEST RTAKEKEY .
6: 4 ROPENCHEST
→ RUNLOCKCHESTRLIFTLID .
4
36 :: 24 RROOMCHANGEROOM1T
SABLE →→ IPULLLEVEROOPENDOOR.
0 IMAKEDOORPAS
ROPEN CHEST O ROOM2 →→ RTRUNLHROUGHDOOR.
OCKCHEST RLRIFETNTLEIDR.ROOM2
→ RROOM1TO ROOM2. R OPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
6: 02 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST .RTAKEKEY
RRETRI
E
VEKEY
RROOM1TOROOM2.ROPENCHES
T
RTAKEKEY
4:
0
RRETRIEVEKEY
RROOM1TOROOM2ROPENCHES
T RTAKEKEY.
2 : IMAKEDOORPAS ABLE → IPUL LEVER OOPEN DOOR.
4: RROOM1TOROOM2
→ IMAKEDOORPASSABLERROOMCHANGEROOM1TOROOM2.
6 : 4 ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID .
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST.RTAKEKEY
HROUGHDOORRE
64 :: 02 RRERROOMCHANGEROOM1T
TRIEVEKEY O ROOM2 →→ RTRROOM1T
O ROOM2ROPNTERENROOM2.
CHEST . R TAKEKEY
2:7: 00 ROPENCHES
RROOM1TOROOM2
→→ .RUNLOCKCHES
IMAKEDOORPAS
SARLIBLE.RROOMCHANGEROOM1TOROOM2
4 : 40 ROPEN CHEST
→ . R UNLOCK CHEST RLIFT LID
7: 00 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY.
4:
T
→
T
F
TLI
D
4
2 : RROOM1TO ROOM2 → IMAKEDOORPAS ABLE . R ROOMCHANGEROOM1TO ROOM2
→ RROOM1TOROOM2.ROPENCHEST RTAKEKEY
4: 0 RRETRIEVEKEY
6 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST . R TAKEKEY
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHESTRTAKEKEY.
47 :: 00 RROOM1T
→→ IMAKEDOORP
AS ABLE RROOMCHANGEROOM1T
RRETRIEVEKEO ROOM2Y
RROOM1TO ROOM2ROP
EN CHEST RTAKEKEY . O ROOM2.
4 : 40 ROPEN CHEST
→ . R BREAKCHEST
2:4: 2 RROOMCHANGEROOM1TOROOM2
→→ .RTHROUGHDOORRENTERROOM2
.RBREAKCHEST
2 : RROOMCHANGEROOM1TO ROOM2 → . R THROUGHDOORRENTER ROOM2
4: 4 ROPENCHEST
→ .RUNLOCKCHEST RLIFTLID
7 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
4 ROPENCHEST
→ RROOM1TO ROOM2.ROPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
5 : 42 ROPEN CHEST
→ RUNLOCK CHEST . R LIFT LID
→→ RTHROUGHDOOR.RENTERROOM2
3:5: 2 RROOMCHANGEROOM1TOROOM2
3 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOOR. R ENTER ROOM2
4: 4 ROPENCHEST
→ .RBREAKCHEST
RUNLOCKCHEST .RLIFTLID
4 : 4 ROPEN CHEST
→ .RUNLOCKCHEST RLIFT LID
4 ROPENCHEST
6 : 4 ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID .
4: 2 ROPENCHES
RROOMCHANGEROOM1TOROOM2
→→ RTHROUGHDOORRENTERROOM2.
4 : 2 RROOMCHANGEROOM1TO ROOM2 → RTHROUGHDOORRENTER ROOM2.
ROPENCHES
5:
T
→
RUNLOCKCHES
T
.RLI
F
TLI
D
4
:
ROP
E
N
CHE
S
T
→
.RBRE
A
KCHE
S
T
4
4
6:
T
RUNLOCKCHES
T
RLI
F
TLI
D
.
4
6 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST . R TAKEKEY
4 : 0 RROOM1TO ROOM2 → IMAKEDOORPAS ABLE RROOMCHANGEROOM1TO ROOM2.
6: 4 ROPENCHEST
→ RUNLOCKCHEST RLIFTLID .
5 : 4 ROPEN CHEST
→ RUNLOCKCHEST . R LIFT LID
RROOM1TOROOM2
→→ IMAKEDOORPAS
SABLERROOMCHANGEROOM1TOROOM2.
6:4: 00 RRETRI
EVEKEY
RROOM1TOROOM2ROPENCHES
T .RTAKEKEY
7 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
6 : 4 ROPEN CHEST
→ RUNLOCKCHEST RLIFT LID .
→ RROOM1TO ROOM2. R OPEN CHEST RTAKEKEY
4 : 0 RRETRIEVEKEY
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST .RTAKEKEY
RRETRIEEVEKEY
VEKEY
RROOM1TOROOM2.ROPENCHESTTRTAKEKEY.
RTAKEKEY
7:4: 00 RRETRI
→→ RROOM1TOROOM2ROPENCHES
6 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST . R TAKEKEY
4 : 4 ROPEN CHEST
→ . R UNLOCK CHEST RLIFT LID
7: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST RTAKEKEY.
4: 4 ROPENCHEST
→ .RUNLOCKCHEST RLIFTLID
7 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
4 : 4 ROPEN CHEST
→ . R BREAKCHEST
4: 4 ROPENCHEST
→ .RBREAKCHEST
5 : 4 ROPEN CHEST
→ RUNLOCK CHEST . R LIFT LID
5: 4 ROPENCHEST
→ RUNLOCKCHEST .RLIFTLID
6 : 4 ROPEN CHEST
→ RUNLOCK CHEST RLIFT LID .
6: 4 ROPENCHEST
→ RUNLOCKCHEST RLIFTLID .
6 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST . R TAKEKEY
6: 0 RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHEST .RTAKEKEY
7 : 0 RRETRIEVEKEY
→ RROOM1TO ROOM2ROPEN CHEST RTAKEKEY .
I PUL LEVER OOPEN DO R RTHROUGH DO R RENTER RO M 2RUNLOCK CHEST RLIFT LID RTAKE KEY

select(DOOR)

select(OPEN)

select(OPEN,select(DOOR))

Figure 3: Filter functions applied to affordance example

actions players were ever observed to perform in a room combination.

spatial location (“west”, “left”), spatial indexicality (“this”,
“that”), temporal indexicality (“let’s try that again”) and possession (“my lever”) encoding
some
specific meanings for the
7: RRETRIEVEKEY
→ RROOM1TOROOM2ROPENCHES
T RTAKEKEY.
game context. For example, a lever belongs to a player (“my
lever”) if the player was the one to most recently interact with
it.
Whenever one player gives the other a directive, the utterance is parsed by the language parser to produce an affordance filter specification. The plan recognizer then runs
this filter specification on the complete set of affordances produced up to this point in the game, which yields a filtered set
of affordances. These are then ranked using their probabilities. If the best result is not currently applicable, the system plans towards a state in which it would be applicable and
makes its prediction the first step along that plan. To measure performance, the final prediction is compared to the next
action the player in question actually takes, and counted as
correct if it matches.
The first row of Table 2 (All Directives (AD)) shows the
performance on the complete set of directives. However,
players do not always follow instructions, so the second row
(Followed Directives (FD)) shows performance only on the
281 cases where the player actually performs an action that
matches the directive as determined by the annotator (64 in
the testing session). As many directives are short utterances
marking the time to take and action rather than providing linguistic content (we call them action markers), the row Followed Long Directives (FLD) in Table 2 shows performance
on the half of the directives that contain more than one word.
The gap to the pure plan recognition baseline widens significantly on this utterance set, showing that the system can
understand more complex language and produce the correct
concept for many of these directives.
Table 3 shows a number of prediction baseline results for
the same data sets. Row 1 of Table 3 shows the performance if
language is ignored - that is, if we simply pick the most probable prediction of the plan recognizer at the point an utterance occurs, without paying attention to the words in the utterance. As above Plan Recognition (FLD) restricts the pure
plan recognition baseline to those directives that were correctly acted upon by the listener and use more than one word.
Finally, State Based Random randomly picks amongst all the
0

Table 2: Accuracy Results for Understanding Directives
Selected Utterances

Development

Test

All Directives (AD)
Followed Directives (FD)
Followed Long Directives (FLD)

70%
72%
61%

68%
70%
68%

Table 3: Prediction Baselines
Prediction Type

Development

Test

Plan Recognition (AD)
Plan Recognition (FLD)
Random (AD)

65%
50%
15%

63%
60%
17%

When interpreting these results, it is important to keep
in mind that perfect prediction cannot and should not be
achieved in any of these cases. The puzzle naturally causes
much exploration by the players, and, as will be discussed further below, situations and directives often do not limit players to a single next action. Some amount of variability is
thus inherent in the scenario. The best overall performance
of the complete system was 72%. Given the complexity of
the problem and the leeway players appear to give each other
in following their own utterance, this figure indicates that the
theory and implementation presented in this paper make for
an effective substrate for language understanding systems.
The low random baseline shows that prediction is no simple task (even this baseline does not pick amongst all possible actions, but only those players performed in the development data). Language understanding heavily relies on plan
recognition - often the meaning of an utterance is highly constrained by the player’s states and plans. Taking the words
into account, however, improves again on the pure plan recognition performance. The best measure of this improvement
is the 11% gain (8% in the test set) seen when considering
the set of correctly followed directives longer than one word.
283

Gorniak, P. J. and Roy, D. (2004). Grounded semantic composition for visual scenes. Journal of Artificial Intelligence
Research, 21:429–470.
Harnad, S. (1990). The symbol grounding problem. Physica
D, 42:335–346.
Laurence, S. and Margolis, E. (1999). Concepts and cognitive
science. In Margolis, E. and Laurence, S., editors, Concepts: Core Readings, chapter 1, pages 3–81. MIT Press.
Miller, G. A., Galanter, E., and Pribram, K. H. (1960). Plans
and the Structure of Behavior. Adams, Bannister, Cox,
New York.
Narayanan, S. (1997). KARMA: Knowledge-based Action
Representations for Metaphor and Aspect. PhD thesis,
University of California, Berkeley.
Plunkett, K., Sinha, C., Moller, M., and Strandsby, O. (1992).
Symbol grounding or the emergence of symbols? vocabulary growth in children and a connectionist net. Connection
Science, 4(3&4):293–312.
Prinz, J. (2002). Furnishing the Mind: Concepts and their
Perceptual Basis. MIT Press, Cambridge, MA, USA.
Pynadath, D. V. and Wellman, M. P. (2000). Probabilistic
state-dependent grammars for plan recognition. In Proceedings of the Conference on Uncertainty in Artificial Intelligence, UAI2000. Morgan Kaufmann Publishers.
Regier, T. (1996). The Human Semantic Potential. MIT Press.
Rosch, E. (1975). Cognitive representations of semantic categories. Journal of Experimental Psychology, 104:192–233.
Roy, D. (2002). Learning words and syntax for a visual description task. Computer Speech and Language, 16:353–
385.
Roy, D. (2003). Grounded spoken language acquisition: Experiments in word learning. IEEE Transactions on Multimedia, 5(2):197–209.
Roy, D. (2005). Semiotic schemas: A framework for grounding language in action and perception. Artificial Intelligence.
Roy, D., Gorniak, P. J., Mukherjee, N., and Juster, J. (2002).
A trainable spoken language understanding system. In Proceedings of the International Conference of Spoken Language Processing.
Schuler, W. (2003). Using model-theoretic semantic interpretation to guide statistical parsing and word recognition in a
spoken language interface. In Proceedings of the Association for Computational Linguistics.
Siskind, J. M. (2001). Grounding the lexical semantics of
verbs in visual perception using force dynamics and event
logic. Journal of Artificial Intelligence Research, 15:31–
90.
Steedman, M. (2002). Formalizing affordance. In roceedings of the 24th Annual Meeting of the Cognitive Science
Society, pages 834–839.
Stolcke, A. (1995). An efficient probabilistic context-free
parsing algorithm that computes prefix probabilities. Computational Linguistics, 21(2):165–201.
Stoytchev, A. (2005). Behavior-grounded representation of
tool affordances. In Proceedings of IEEE International
Conference on Robotics and Automation (ICRA), page ??
Yu, C., Ballard, D., and Aslin, R. (2003). The role of embodied intention in early lexical acquisition. In Proceedings of
the Cognitive Science Society.

The performance gain is smaller when considering all utterances because performance is dominated by action markers,
for which linguistic content plays little role, and thus yields
no improvement in performance.
Performance on the test utterances is entirely comparable
to that on the development utterances, showing that the plan
recognition grammar and linguistic parser, while restricted in
their coverage, generalize well to unseen data. Of note is
that individual sessions differ greatly in playing and communication style. In fact, there is a single session in the test
set that contains very repetitive and easily predicted player
behaviour. When it is omitted, the test set performance baselines are equals to or lower than the development set baselines.

Conclusion
We have outlined a theory of concepts based on perceived
affordances: structured units of mental representation that
make predictions about possible interactions. We believe the
ABC theory to be a useful new view of mental representation of concepts. It is unique in its computational interpretation of Gibsonian affordances based on plan recognition,
and its successful realization in a language understanding task
dealing with spontaneous, situated human language. The implementation presented in this article provides a convenient
framework for probabilistic hierarchical reasoning about affordances while understanding situated language. It will be
important to integrate this framework with other approaches
and views on affordances (Steedman, 2002; Roy, 2005) and
to re-phrase existing approaches dealing with other aspects
of grounded language understanding in an affordance-based
framework.

References
Bobick, A. F. and Ivanov, Y. A. (1998). Action recognition
using probabilistic parsing. In Proceedings of the IEEE
Conference on Computer Vision and Pattern Recognition.
Carey, S. (1985). Conceptual Change in Childhood. MIT
Press.
Carnap, R. (1932). Überwindung der metaphysik durch logische analyse der sprache. Erkenntnis, 2.
Earley, J. (1970). An efficient context-free parsing algorithm.
Communications of the ACM, 6(8):451–455.
Fleischman, M. and Roy, D. (2005). Why are verbs harder
to learn than nouns? In Proceedings of the 27th Annual
Meeting of the Cognitive Science Society.
Gibson, J. (1977). The theory of affordances. In Shaw, R.
and Bransford, J., editors, Perceiving, Acting and Knowing,
pages 67–82. Wiley, New York.
Gorniak, P. (2005). The Affordance-Based Concept. PhD
thesis, Massachusetts Institute of Technology.
Gorniak, P. and Roy, D. (2005a). Probabilistic grounding of
situated speech using plan recognition and reference resolution. In Proceedings of the International Conference on
Multimodal Interfaces.
Gorniak, P. and Roy, D. (2005b). Speaking with your sidekick: Understanding situated speech in computer role playing games. In Proceedings of Artificial Intelligence and
Digital Entertainment.
Gorniak, P. and Roy, D. (in review, 2006). Situated language
understanding as filtering perceived affordances. in review.
284

