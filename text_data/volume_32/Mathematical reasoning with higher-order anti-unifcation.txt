UC Merced
Proceedings of the Annual Meeting of the Cognitive Science
Society
Title
Mathematical reasoning with higher-order anti-unifcation
Permalink
https://escholarship.org/uc/item/4w0023k9
Journal
Proceedings of the Annual Meeting of the Cognitive Science Society, 32(32)
Authors
Guhe, Markus
Pease, Alison
Smail, Alan
et al.
Publication Date
2010-01-01
Peer reviewed
 eScholarship.org                              Powered by the California Digital Library
                                                                University of California

                      Mathematical reasoning with higher-order anti-unifcation
                                              Markus Guhe, Alison Pease, Alan Smaill
                                                  (m.guheja.peaseja.smaill@ed.ac.uk)
    University of Edinburgh, School of Informatics, Informatics Forum, 10 Crichton Street, Edinburgh E H 8 9 A B, Scotland
                           Martin Schmidt, Helmar Gust, Kai-Uwe Kühnberger, Ulf Krumnack
                                  (martischjhgustjkkuehnbejkrumnack@uni-osnabrueck.de)
               University of Osnabrück, Institute of Cognitive Science, Albrechtstr. 28, 49076 Osnabrück, Germany
                               Abstract                                  talking about collections of objects, such as physically placing
   We show how heuristic-driven theory projection (H D T P, a            an object into a container, e.g. adding an onion to the soup, or
   method based on higher-order anti-unification) can be used to         physically removing a substance or an object from a container,
   model analogical reasoning in mathematics. More precisely,            e.g. take a book out of the box.
   H D T P provides the framework for a model of the inductive
   analogy-making process involved in establishing the fundamen-            Analogical reasoning is a central component of the pro-
   tal concepts of arithmetic. This process is a crucial component       cess transforming knowledge of this kind into mathematical
   for being able to generalise from the concrete experiences that       concepts. For present purposes we assume that metaphor and
   humans have due to their embodied and embedded nature. Such
   generalisations are a cornerstone of the ability to create an ab-     analogy are essentially the same cognitive process (Gentner,
   stract domain like arithmetic. In addition to generalisations,        Bowdle, Wolff, & Boronat, 2001), and we have demonstrated
   H D T P can also transfer concepts from one domain into an-           how structure mapping (Gentner, 1983; Gentner & Markman,
   other, which is, for example, needed to introduce the concept
   Z E R O into arithmetic. The approach presented here is closely      1997) – a basic method to compute analogical relations – can
   related to the theories of Information Flow and Institutions.         account for the overall cognitive process (Guhe, Pease, &
   The latter in particular provides a compelling way to integrate       Smaill, 2009).
   concept blending into the HDTP approach.
                                                                            In this paper, we describe a formal cognitive model of this
   Keywords: mathematical cognition; mathematical reasoning;
   analogy; anti-unification; concept blending                           process. This has a twofold motivation: firstly, we want to spec-
                                                                         ify the cognitive processes that mathematicians use, to better
 Mathematical reasoning as a cognitive process                           understand how mathematical discovery works; secondly, we
Although mathematics is usually presented in terms of axioms,            want to use the model to improve automated theorem provers
concise proofs, theorems and so on, the actual cognitive pro-            by incorporating cognitive mechanisms. In Guhe, Smaill, and
cess of mathematical reasoning is very different. For example,           Pease (2009a, 2009b) we presented formal representations of
when a mathematician changes a definition this affects the               the four grounding metaphors (the 4Gs) and suggested how
proofs that use it, but such changes are not discussed in mathe-         Information Flow theory (Barwise & Seligman, 1997) may be
matical papers. Additionally, mathematics, at least partly, does         used to model the analogies involved. The 4Gs are: (1) arith-
not consist of discovering eternal, Platonic ideals but in cre-          metic is object collection, (2) arithmetic is object construction,
ating mathematical concepts. For example, Lakatos’s (1976)               (3) measuring stick and (4) arithmetic is motion along a path.
account of the history of Euler’s conjecture illuminates how                Here, we present a proof-of-concept of how performing
the concept P O LY H E D R O N can differ and how its definition         anti-unification (Plotkin, 1970) on such representations can
depends on the current circumstances and needs of the mathe-             account for aspects of the analogical reasoning involved in
matician. Put differently, if the Platonic ideal P O LY H E D R O N      the 4Gs. This inductive kind of reasoning provides us with a
does exist, it is not clear how it can be identified by mathemat-        procedural version of the otherwise static Information Flow
ical means – what cognitive processes mathematicians can use             models and enables us to computationally determine the re-
to find the correct definition. Thus, mathematical concepts are          lationships between the domains (classifications in the case
not necessarily the same as the ideals.                                  of Information Flow). More precisely, we will use Heuristic-
   Lakoff and Núñez (2000) describe how our embodied, situ-            Driven Theory Projection (H D T P; Schwering, Krumnack,
ated experience is the basis on which abstract mathematical              Kühnberger, & Gust, 2009), a general framework for making
concepts are developed by a process of metaphorical abstrac-             analogies. H D T P provides us with the means to generalise
tion and transfer. In chapter 3, they describe how basic arith-          over two of Lakoff and Núñez’s domains to establish a basis
metic is created from four everyday experiences, which are               for arithmetic as well as the means to generalise over one of
the source domains of the metaphors. In this way, arithmetic             the domains as source domain and arithmetic as the target
is grounded in situated cognition. To motivate that these four           domain to add concepts to arithmetic that are only present in
domains in particular are source domains, Lakoff and Núñez             one of the grounding domains. We will also outline how this
analyse linguistic expressions used in the target domain, arith-         conception of mathematical reasoning is linked to Goguen’s
metic, which they trace back to these four domains. For exam-            (2006) notion of concept blending (which is based on notions
ple, we use the terms add and take away in arithmetic. Lakoff            by Gärdenfors, 2000 and Fauconnier & Turner, 2002), a fur-
and Núñez argue that these terms were originally used for              ther cognitive process for creating mathematical concepts.
                                                                     1992

                Metaphors for arithmetic                                  Table 2: Arithmetic is object construction metaphor (Lakoff &
Arithmetic is object collection                                           Núñez, 2000, pp. 65–66)
The arithmetic is object collection metaphor (Table 1) is based             object construction                       arithmetic
on the notion that the repeated manipulation of (small, count-              objects                                   numbers
able, physical) collections of objects lets us notice certain               smallest whole object                     the unit (one)
regularities. For example, we can determine which one of two                size of object                            size of number
collections is bigger by aligning the objects in the two col-               bigger                                    greater
lections one-to-one, and the collection that has at least one               smaller                                   less
unpaired object left over is the bigger collection. (Smaller                constructed object                        result of arith.
and equal are, of course, determined correspondingly.) This                                                             operation
corresponds to the (abstract) arithmetic notion G R E AT E R .              whole object                              a whole number
   By comparing collections of objects in this way we can                   putting objects together to form          addition
also group such collections into groups of collections of equal                larger objects
size, i.e. where after the aligning procedure no object is left             taking smaller objects from larger        subtraction
unpaired. Each of these groups corresponds to a number in                      objects to form other objects
arithmetic.
   There are two things to note about this basic metaphor.
Firstly, it does not produce a concept of Z E R O , because the           Arithmetic is motion along a path
empty collection is a collection that does not exist physically.          The motion along a path metaphor (Table 3) adds concepts
(Even calling one object a collection with one object is an               to arithmetic that we experience by moving along straight
abstraction of the term collection.) Lakoff and Núñez (2000,            paths. Numbers are point locations on paths. Addition and
p. 64) propose that an entity-creating metaphor is required to            subtraction correspond to a movements from point one point
create a concept that is not part of the basic metaphor (like             on the path to another point on the path. An important new
Z E R O ). This corresponds well with the fact that, historically,        concept that is added to arithmetic by this metaphor is Z E R O ,
Z E R O was a rather late invention. Secondly, the subtraction            which is based on the concept of a path’s origin and which
operation requires that a smaller collection be taken from a              provides a direction for the movements along paths, namely
bigger one, because physically, negative objects do not exist.1           towards the origin or away from it.
Table 1: Arithmetic is object collection metaphor (Lakoff &               Table 3: Arithmetic is motion along a path metaphor (Lakoff
Núñez, 2000, p. 55)                                                     & Núñez, 2000, p. 72)
     object collection                            arithmetic                motion along a path                       arithmetic
     collections of objects of the same size      numbers                   acts of moving along the path             arith. operations
     size of collection                           number                    a point location on the path              result of an oper-
     bigger                                       greater                                                               ation; number
     smaller                                      less                      origin; beginning of the path             zero
     smallest collection                          the unit (one)            unit location, a point location distinct  one
     putting collections together                 addition                     from the origin
     taking a smaller collection from a           subtraction               further from the origin than              greater
        larger collection                                                   closer to the origin than                 less
                                                                            moving away from the origin a             addition
                                                                               distance
Arithmetic is object construction                                           moving toward the origin a distance       subtraction
The arithmetic is object construction metaphor (Table 2) runs
along the same lines, except that it is not based on collections
of objects, but on objects that are constructed from smaller                       Heuristic-Driven Theory Projection
objects. In this way, fractions are added to arithmetic, although         Overview
they are not part of the basic metaphor. Consider, for example,
                                                                          This section provides a short overview of the basic ideas of
an object that is constructed out of seven smaller objects. If
                                                                          heuristic-driven theory projection (H D T P), a formal frame-
now a smaller object that consists of three of the seven overall
                                                                          work to model analogical mapping and reasoning. A more
objects is removed from the original object, the two resulting
                                                                          detailed description can be found in Schwering et al. (2009).
objects have a size of 73 and 47 of the original.
                                                                             H D T P establishes analogies between two domains, the
    1 One is reminded of the old joke: If on one floor 5 people leave     source and the target, by detecting common structures. In the
an elevator containing 3 people, 2 people have to enter the elevator      mapping phase, source and target are compared for structural
on the next floor in order for it to be empty.                            commonalities and a generalised description is created, which
                                                                      1993

subsumes the matching parts of both domains. In the transfer                       domains:
phase, unmatched knowledge in one domain can be mapped
                                                                                                                        GeneralisationG
to the other to establish new hypotheses.                                                                                    r         GG
                                                                                                                           rr            GG
   H D T P is a formal framework that computes analogical                                                             rrr                   GG
                                                                                                                 r rr                            GG
relations and inferences for domains represented in first-order                                               x r            analogical            #
                                                                                              Object Collection          o                  /  Arithmetic
logic. Both, source and target domain, are given by axiomati-                                                                 relation
sations, i.e. finite sets of first-order formulae. The basic idea
is to associate pairs of formulae from the domains in a sys-                       In this model, both domains are already given. The analogy
tematic way. H D T P uses anti-unification (Plotkin, 1970) to                      explains abstract concepts like numbers by linking them to
identify common patterns in formulae. In anti-unification, two                     familiar entities from the grounded domains. Thus, the gener-
formulae are compared and the least general generalisation                         alisation provides a description of the commonalities of the
that subsumes both formulae is identified.                                         grounded and the abstract domains.
   Figure 1 provides some examples of anti-unification of                             However, from the cognitive perspective, Arithmetic does
terms. Terms are generalised to an anti-instance where differ-                     not initially exist – it has to be created by an act of abstraction
ent constants or function symbols are replaced by a variable.                      as well. This idea can be modelled by analogically relating
In (i), first-order anti-unification is sufficient. However, the                   two grounded domains, e.g. Object Collection and Object Con-
terms in (ii) differ in the function symbols, i.e. first-order                     struction. Arithmetic then emerges as a generalisation of these
anti-unification fails to detect structural commonalities. Here,                   domains.
higher-order anti-unification generalises function symbols to a                                                 Generalisation
variable and retains the structural commonality. It is even pos-                                                   (Arithmetic
                                                                                                                     v           JJ)
                                                                                                                   vv               JJ
                                                                                                                vv                    JJ
sible to generalise terms in which common parts are embedded                                                vv                           JJ
                                                                                                        z vv                                  J%
structurally in a different way, as shown in (iii).2 Substitutions
                                                                                          Object Collection                         Object Construction
accompanying the generalised terms are created, which can be
used to reconstruct the original terms.                                            In our view, a combination of both approaches is needed to
                                                                                   model the cognitive bootstrapping process. By generalising
         f (X )                   F (a)                 F (a; b)                   over two grounded domains, an abstract domain is estab-
     !
              **
            ** X b         !
                                        *
                                      **
                                              !     !f
                                                              66
                                                                          !
   X a
                 **  !    F    f  * F g
                                         **
                                                  F             66F (x;y)
                                                                   66h(x;g(y))
                                                                                   lished, which serves as a ‘proto-domain’ of Arithmetic, i.e.
                                                                           a domain that already contains some arithmetical concepts.
    f (a)        f (b)       f (a) g(a)         f (a; b)       h(a; g(b))          This is then refined subsequently, by relating it analogically
            (i)                       (ii)                  (iii)                  to other grounded domains, removing peculiarities of the two
                                                                                   original domains and/or adding new concepts by analogical
                      Figure 1: Anti-unification of terms                          transfer.
                                                                                                                    Generalisation
   H D T P extends this classical anti-unification of terms to                                                       (Arithmetic-2
                                                                                                                           x      ; )
                                                                                                                         x         ;;
formulae and logical theories by iteratively picking pairs of                                                        xx              ;;
formulae to be generalised from the domains. This process                                                         |xx                  ;;
                                                                                                 Generalisation                          ;;
                                                                                                                                           ;;
is driven by heuristics. Coherent mappings are preferred, i.e.                                    (Arithmetic-1
                                                                                                                 DD )i                        ;;
                                                                                                                    DD         transfer          ;;
mappings in which substitutions can be reused. The gener-                                                             DD
alised theory together with its substitutions specifies the ana-                                                        "                  ) ;
                                                                                             Object                   Object                       Motion
logical relation between source and target. Additional informa-                           Collection             Construction                 Along a Path
tion about the source domain, i.e. formulae with no correspon-
dence in the target domain, can be transferred by replacing                        It should be noted that in pursuing this approach the results
symbols using the established substitutions.                                       may vary depending on which grounded domains are chosen
                                                                                   for generalisation and on the order in which other grounded
Modelling the arithmetical metaphors                                               domains are added for refinement. This is due to the heuristics
H D T P provides two different ways in which Lakoff and                            that HDTP applies when building up the generalisation. The
Núñez’s (2000) grounded domains (Object Collection, Object                       more similar the grounded domains are, the richer the general-
Construction etc.) can be related to the abstract domain of Arith-                 isation will be, while dissimilar domains give coarser results.
metic. Following Lakoff and Núñez, the grounded domains                          Nevertheless, we expect that this effect can be compensated
constitute the source, while Arithmetic is the target domain.                      by further mapping the initial generalisation to other domains.
To establish an analogical relation between Object Collection                      A detailed examination of this will be a focus of our future
and Arithmetic, HDTP can construct a generalisation of these                       work.
    2 HDTP         uses a restricted form of higher-order substitutions, that      Formalisation of domains
allows to expand terms by introducing arguments and nested struc-
tures as described in Krumnack, Schwering, Gust, and Kühnberger                   We demonstrate the feasibility of the outlined approach by
(2007).                                                                            applying it to simple formalisations of Lakoff and Núñez’s
                                                                               1994

                                                                        ρ1 : →       ∀V1 ,V2 : bigger(V          ,C1 ) 1 ,V2 )τ→      3 : smaller(V
                                                                                                                                              P(V1 ,V2 ,V       2 ,V3 )1−→)             → smaller(O2 , O1 )                                  σ1 : ∀V1 ,V2 : G(V                       1 ,V2 ) → L(V2 ,V1 ) 1 , P2 , Path)
Unification                                                                      τ2 : smaller(C
                                                                                            L(V1 ,V2 )2−→                                                                                                                                                                           furtherFromOrigin(P
                                                                        ρα22:: ∀V        closerToOrigin(V    :  P(V                   )     moveAwayFromOrigin(V
                                                                                                                                        Path)   M(V                      )                     1 ,V2 ,V3 , Path)                             σ       :   ∀V        ,V     ,V     :  →P(V   closerToOrigin(P
                                                                                                                                                                                                                                                                                              1 ,V2 ,V3 ) → M(V23,,V               P12,,VPath)
                                                                                                                                                                                                                                                                                                                                           1)
                                                                                             ,V
                                                                                       ∀C11 ,C2 2 ,C,V                    ,V
                                                                                                         3 3 : putTogether(C
                                                                                                                       1 12 23  ,V    ,   →    1 ,C2 ,C
                                                                                                                                                          ,V
                                                                                                                                                        3 32) 1  ,V               β2 : ∀ O1 , O2 , O3 : combine(O1 , O2 , O3 )                  2                1      2     3
Formalization of the Arithmetic   Abstract                              ρ  3 3Metaphors
                                                                               : τ → ∀V: takeAway(C
                                                                                            P(V
                                                                                             ,V     ,V
                                                                                           1 21 32 43 ,V    ,V
                                                                                                             ,V    3:
                                                                                                                    ),C     ,C
                                                                                                                       (align(V
                                                                                                                        −→2      1 )τ4 ,V
                                                                                                                                       1 2
                                                                                                                                          : M(V ) ∧   P(V
                                                                                                                                                      1  ,V2 ,V ,V
                                                                                                                                                              2 3 4  3 ),V−→    ))   →  →     split(O
                                                                                                                                                                                          bigger(V         3
                                                                                                                                                                                                          4 1
                                                                                                                                                                                                             ,
                                                                                                                                                                                                             ,VO   2), O  1  )               σ  3    :   ∀V      1 ,V   2 ,Vγ 2
                                                                                                                                                                                                                                                                              3  :
                                                                                                                                                                                                                                                                                ,V   4∀  :P  (A(V
                                                                                                                                                                                                                                                                                             1  ,  P  2  ,
                                                                                                                                                                                                                                                                                                         1  P
                                                                                                                                                                                                                                                                                                            ,V 3  ,
                                                                                                                                                                                                                                                                                                                  2 Path
                                                                                                                                                                                                                                                                                                                    )  ∧   :
                                                                                                                                                                                                                                                                                                                          P(V  2 ,V 3  ,V 4 )) → G(V4 ,V
                                                                                         moveAwayFromOrigin(V                               moveTowardsOrigin(V
                                                                                                                                                     ,V)3 , Path) β3 : 1∀,V                      2 ,V3 , Path)                                                                      moveAwayFrom(P1 , P2 , P3 , Path)
                                                                          α       :                                    :                       ,V,V                                            O      O      O       O     :                 σ
                                                                        ρ                                                                                                                                                                            :                     : S(V                   (¬Q(V
                                                                                                                                                                                                                                                                                    → moveTowardsOrigin(P1 , P))
                                                                                                                                                                                                                                                                                       )                              )
      filled . . .
to be Collection                                                              3:     ∀V∀C    1
                                                                                             ,V ,C  2 :,CS(V3  ,C ) 4→     ¬bigger(V        1      2                                              1 ,    2 ,    3  ,    4                       4        ∀V      1 ,V   2            1     →                        2    →  ¬G(V      1 ,V 2
 ject                                                                      4               1 2                  1
                                                                                                                                    τ5 : A1 −→        2                                                                                                                                                                                      2 , P3 , Path)
                                                                                 τ(align(C              ,C ) ∧ putTogether(C
                                                                                    4 : M(V11 ,V22,V3 ) −→                                        2 ,C3true ,C4 ))                      (align(O1 , O2 ) ∧ combine(O2 , O3 , O4 ))
Keywords:
Object ConstructionMathematical Cognition; Analogies;                              → bigger(C             Anti-
                                                                                                            4  ,C   1 )
                                                                                         moveTowardsOrigin(V61 ,V2 ,V3 , Path)      τ     :   S   −→       closestToOrigin              →     bigger(O          4 , O  1 )                                                  γ 3  :    ∀   P  1  ,  P  2  ,  P  3  , P 4 , Path   :
Unification
Motion Along A Path                                                                                                                                                                                                                                                                 moveAwayFromOrigin(P2 , P3 , P4 , Path)
                                                                          α4 τ: 5 ∀C   : A1 ,C  −→  2 : true
                                                                                                           smallestCollection(C     τ7 : Q(V11)) −→ origin(V                      β4 1: , Path)
                                                                                                                                                                                            ∀ O1 , O2 : smallestWholeObject(O1 )
                                                                                   → ¬bigger(C1 ,C2 )                                                                                   → ¬bigger(O1 , O2 )                                                                         → furtherFromOrigin(P4 , P1 , Path)
aaaa                                                                             τ6Metaphors
                                                                                       : S −→ closestToOrigin
Formalization of the Arithmetic                                         σ1 : ∀V1 ,V2 : G(V1 ,V2 ) → L(V2 ,V1 )
                                                                                                                                                                                                                                                                            γ
                                                                                                                                                                                                                                             τ1 : G(V1 ,V2 ) −→∀ P1 , P2 , Path : closestToOrigin(P1 )
                                                                                                                                                                                                                                                                              4  :
                                                                                 τ7 : Q(V1 ) −→ origin(V1 , Path)                                                                                                                                     furtherFromOrigin(V           → (¬origin(P                      2 , Path) →
 ject Collection                                                                                                                                                                                                                                                                                      1 ,V2 , path)
                            Generalisation σ2 : ∀V1 ,V2 ,V3 : P(V1 ,V2 ,V3 ) → M(V3 ,V2 ,V1 )                                                                                                                                                                                                   ¬furtherFromOrigin(P                        1 , P2 , Path))
Object Construction                                                                                                                                                                                                                          τ2 : L(V1 ,V2 ) −→
                             (Arithmetic-2) σ3 : ∀V1 ,V2 ,V3 ,V4 : (A(V1 ,V                                                           2 ) ∧ P(V2 ,V3 ,V4 )) → G(V4 ,V1 )                                                                                                    γ 5  :
                                                                                                                                                                                                                                                      closerToOrigin(V1 ,V2 , path)   ∀   P  1  ,  Origin,            Path   :
Motion Along A Path                                                                                                                 κ1 : G −→ bigger                                                                                                                                moveTowardsOrigin(P                   Abstract 1 , P1 , Origin, Path
                                         aaaa                           σ4 : ∀V1 ,V2 : S(V1 ) → (¬Q(V2 ) → ¬G(V1 ,V2 ))                                                                                                                      τ     :     P(V1 ,V2 ,V3 )→
aaaa                                                                                                                                κ  2  :    L  −→        smaller                                                                            3                                     −→    origin(Origin, Path)
                            Generalisation                                                                                                                                                                                                            moveAwayFromOrigin(V
                                                                                                                                                                                                                                                               to be filled . . .                                1 ,V2 ,V3 , path)
                                                                                 κ1 : G −→ bigger                                   κ3 : A −→ align
                             (Arithmetic-1)                                                                                                                                                                                                  τ4 : M(V              1 ,V2 ,V3 ) −→ Mathematical Cognition; Analo
                                                                                                                                                                                                                                                               Keywords:
                                                                                 κ2 : L −→ smaller                                  κ4 : Q −→ f alse                                                                                                  moveTowardsOrigin(V
                            Generalisation                                                                                                                                                                                                                     Unification                                1 ,V2 ,V3 , path)
                             (Arithmetic-2) τ : G(V                              κ  3   :   A    −→       align                                                                                                                              τ     :     A   −→        true
                                                                                                                                                                                                                                               5
                                                                                             1 ,V2 ) −→
                                         aaaa                             ρ11 :furtherFromOrigin(V
                                                                                 κ4∀V   : 1Q   ,V−→2 : bigger(V
                                                                                                            f alse 1 ,V,V         2 ) → smaller(V2 ,V1 )                                                                                     τ6 : S −→                 closestToOrigin of the Arithmetic M
                                                                                                                                                                                                                                                                Formalization
                                                                                                                              1 2 , Path)
                            Generalisation τρ22: : L(V                                ∀V1,V
                                                                                            1 2
                                                                                               ,V2),V−→   3 : P(V1 ,V2 ,V3 ) → M(V3 ,V2 ,V1 )                                                                  Abstract                      τ7 : Q(V    Object   1 ) −→        origin(V1 , path)
                                                                                                                                                                                                                                                                          Collection
                             (Arithmetic-1)
                                  Object Collection                       ρ3 :closerToOrigin(V
                                                                                      ∀V1 ,V2 ,V3 ,V4 Abstract       :1(align(V
                                                                                                                         ,V2 , Path)             ) ∧ P(VConstruction
                                                                                                                                        1 ,V2Object            2 ,V3 ,V4 )) → bigger(V4 ,V1 )                                            Motion           Along           A   Path
                                                                                                                                                          to be filled . . .                                                                                   Object          Construction
                                                                        τρ34: : P(V   ∀V1 ,V2 ,V          3 ) −→
                                                                                                       : S(V     1 ) → ¬bigger(V1 ,V2 )                                                                                                                        MotionAnti-      Along A Path
                                                       to be filledmoveAwayFromOrigin(V
                                                                                     ...                                             1 ,V2 ,V3 , Path)    Keywords: Mathematical Cognition; Analogies;
                                α  1   :     ∀C
                                 µ1 : P −→Keywords:1 ,C      2   :   bigger(C
                                                            putTogether                   1 ,C   2 )                                         β  1  :    ∀ Unification
                                                                                                                                                           O
                                                                                                                                                λ1 :Analogies;1  , O
                                                                                                                                                         P −→ combine  2   :   bigger(O         1 , O  2 )                             γ 1 :    ∀    P 1  ,  P 2   :
                                          → smaller(C                   τ4,C: )M(VMathematical
                                                                                             1 ,V2 ,V3 ) −→ Cognition;                              → smaller(O2 , O1 )
                                                                                                                                                                                    Anti-
                                 µ2 : M −→             Unification
                                                              takeAway
                                                                                  1
                                                                        2 moveTowardsOrigin(V
                                                                                                                                 1 ,V2 ,V3λ     , Path)                                                                                      κfurtherFromOrigin(P
                                                                                                                                                                                                                                                1 : G −→ bigger
                                                                                                                                                                                                                                                                                              1 , P2 , path)
                                                                                                                                                  2 : M −→ split                                                                              →      closerToOrigin(P2 , P1 , path)
                                α2 : ∀C1 ,C2 ,C3 : putTogether(C1 ,C2 ,C3 )
                                                 −→ smallestCollection
                                 µ3 :→S takeAway(C                      τ5 :,CA ,C      −→)true
                                                                                                                                             β2 : ∀ O
                                                                                                                                                λ3 →
                                                                                                                                                           Formalization
                                                                                                                                                              1  , O2 , O3 : combine(O                of   1 the
                                                                                                                                                                                                             , O2 , O  Arithmetic
                                                                                                                                                                                                                          3 )                         Metaphors
                                                                                                                                                                                                                                             κ : L −→ smaller
                                                                                                                                                     : Ssplit(O
                                                                                                                                                             −→ smallestW 3 , O2 , O1 )holeOb ject                                     γ2 : 2∀ P1 , P2 , P3 :
                         Object
                           ObjectCollection Collection  Formalization   τ
                                                                          σ13 : 2∀V11,V
                                                                           6   :    S   −→          2 : ofG(Vthe
                                                                                                  closestToOrigin  1 ,V2 )Arithmetic
                                                                                                                               → L(V Object
                                                                                                                                        Object      )Object
                                                                                                                                            2 ,V1ConstructionMetaphors
                                                                                                                                                      Construction    Collection                                                Motion
                                                                                                                                                                                                                                  Motion        3Along
                                                                                                                                                                                                                                               Along
                                                                                                                                                                                                                                             κmoveAwayFrom(P
                                                                                                                                                                                                                                                    : A −→     AAPath   Path
                                                                                                                                                                                                                                                                        align 1 , P2 , P3 , path)
                                α3 : ∀C1 ,C2 ,C3 ,C                       σ    4:: ∀V ,V ,V : P(V ,V ,V ) →                                  β3M(V : ∀O            O2 ,)O3 , O4 :
                                                                                                                                                              1 , ,V
                                                 Object                      2              1       2      3             1     2      3                     ,V
                                                                                                                                                          Object
                                                                                                                                                          3      2       1  Construction                                                      →      moveTowardsOrigin(P
                                                                                                                                                                                                                                             κ4 : Q −→ false                                             3 , P2 , P1 , path)
                                          (align(C           1 ,CCollection
                                                                      2τ)7∧: putTogether(C
                                                                                    Q(V1 ) −→ origin(V           2 ,C3 ,C14,))   Path)              (align(O1 , O2 ) ∧ combine(O2 , O3 , O4 ))
                        αα11 :  : ∀C ∀C   → ,C,C
                                          11 22bigger(C
                                                    :  :   bigger(C
                                                       bigger(C
                                                       Object         4   σ
                                                                         ,C       :
                                                                                  )   ∀V
                                                                             Construction
                                                                             3 1  ,C ,C
                                                                                   1 22   ) )
                                                                                            1  ,V   2 ,V   3 ,V   4  :  (A(V     1  β
                                                                                                                                   ,V  β
                                                                                                                                      112 )
                                                                                                                                          :  ∧
                                                                                                                                             :∀  P(V
                                                                                                                                                 O
                                                                                                                                                 ∀  O
                                                                                                                                                    →  ,2O
                                                                                                                                                     11 22bigger(O
                                                                                                                                                          Motion
                                                                                                                                                          ,V
                                                                                                                                                          , O 3 :,V :  4 ))
                                                                                                                                                                   bigger(O    →
                                                                                                                                                                             Along
                                                                                                                                                                       bigger(O 4 , OG(V
                                                                                                                                                                                       1 )
                                                                                                                                                                                         , A
                                                                                                                                                                                           O,
                                                                                                                                                                                         1 224OPath
                                                                                                                                                                                               ,V) )
                                                                                                                                                                                                   1 )                         γ γ
                                                                                                                                                                                                                                 11:  :γ
                                                                                                                                                                                                                                       ∀ ∀
                                                                                                                                                                                                                                         3P: P ,∀
                                                                                                                                                                                                                                            11 22P,  P ,
                                                                                                                                                                                                                                                       1 Path
                                                                                                                                                                                                                                                          ,  P
                                                                                                                                                                                                                                                             Path
                                                                                                                                                                                                                                                               2  , P: 3: :
                              →  →4smaller(C
                                       :smaller(C                     1 )1σ)Along                                                                smaller(O
                                                                                                                                                    smaller(O              :O  O1 )1 )                                                        moveAwayFromOrigin(P
                                                                                                                                                                                                                                        furtherFromOrigin(P
                                                                                                                                                                                                                                     furtherFromOrigin(P                          1 ,1P , 2P,2Path)
                                                                                                                                                                                                                                                                                                , Path) 1 , P2 , P3 , path)
                                α            ∀C1 ,C         22,C
                                                       Motion   2:,C         4 : ∀V1A,VPath
                                                                     smallestCollection(C           2 : S(V1 1) )→ (¬Q(V2→                  )β→→4 : ¬G(V∀ O11, O   ,V222,2)) ,smallestWholeObject(O                         1)
                                                                                     )                                                                                                 O    )                                        →  →     → furtherFromOrigin(P
                                                                                                                                                                                                                                             closerToOrigin(P
                                                                                                                                                                                                                                          closerToOrigin(P                      2 ,2P          , Path)
                                                                                                                                                                                                                                                                                      , 1P,1Path)     3 , P1 , path)
                        αα22 :  : ∀C ∀C   → ,C ¬bigger(C
                                              ,C
                                          11 22 33 ,C ,C      :  putTogether(C
                                                                  :  putTogether(C
                                                                          1  ,C    2                 ,C ,C
                                                                                                   11 22 33  ,C ,C  )  )            β  β
                                                                                                                                      22  :  :∀  O
                                                                                                                                                 ∀  O
                                                                                                                                                    →  , O  O    O
                                                                                                                                                          ¬bigger(O
                                                                                                                                                          ,
                                                                                                                                                     11 22 33  ,  ,  O   :   :  combine(O
                                                                                                                                                                            combine(O
                                                                                                                                                                                   1 ,    2         , O, O
                                                                                                                                                                                                  11 22 33 , O, O  )  )
                              →→takeAway(C
                                        takeAway(C                   3 ,C
                                                                  3 ,C        2 ,C
                                                                           2 ,C     1 )1 )                                                 →→split(Osplit(O     3 ,3O ,O 2 ,2O ,O1 )1 )                                        γ2γ2: :γ∀4∀P:1P,1∀P, 2P,12P, 3P,23Path closestToOrigin(P
                                                                                                                                                                                                                                                                  ,:Path    ::                                   1)
                                                                        κ      :     G    −→       bigger                                                                                                                                     → (¬origin(P12,1,P,path)
                                                                                                                                                                                                                                        moveAwayFrom(P
                                                                                                                                                                                                                                     moveAwayFrom(P                                2P,2P         →, Path)
                                                                                                                                                                                                                                                                                         , 3P,3Path)
                        αα33 :  : ∀C ∀C     ,C,C   ,C
                                          11 22 33 44 ,C     ,C  ,C    :   :
                                                                           1                                                        β  β
                                                                                                                                      33  :  :∀  O
                                                                                                                                                 ∀  O  , O, O  ,
                                                                                                                                                     11 22 33 44 O,  O  , O,  O   :  :                                                                                                                              P
                                                                                                                                                                                                                                     →→moveTowardsOrigin(P
                                                                                                                                                                                                                                             moveTowardsOrigin(P
                                                                                                                                                                                                                                                         ¬furtherFromOrigin(P                1 ,1P , 2P,2P, 3P        2 , path))
                                                                                                                                                                                                                                                                                                               1,3,Path)
                                                                                                                                                                                                                                                                                                                    , Path)
                                 (align(C
                              (align(C              1 ,C
                                                 1 ,C    2 )2 ∧  ) ∧putTogether(C
                                                                        κputTogether(C
                                                                           2 : L −→ smaller              2 ,C
                                                                                                      2 ,C    3 ,C
                                                                                                                 3 ,C   4 ))
                                                                                                                     4 ))                     (align(O
                                                                                                                                           (align(O          1 ,1O,O  2 )2 ∧
                                                                                                                                                                           ) ∧combine(O
                                                                                                                                                                                   combine(O             ,O
                                                                                                                                                                                                     2 ,2O  3 ,3O,O    4 ))
                                                                                                                                                                                                                    4 ))
                              →→bigger(Cbigger(C                      )
                                                         4 4 1 1 τ1 : G(V1 ,V2 ) −→
                                                             ,C  ,C       )                                                                →  →  bigger(O
                                                                                                                                                    bigger(O           , O
                                                                                                                                                                     44 11,  O  )  )                                           γ γ :  :γ
                                                                                                                                                                                                                                       ∀ ∀P: P ,∀P,  P
                                                                                                                                                                                                                                3 3 5 1 1 2 12 3 3 4 4 , P,  Origin
                                                                                                                                                                                                                                                             P,  P, P , Path
                                                                                                                                                                                                                                                                         ,  :
                                                                                                                                                                                                                                                                           Path   :   :
                                                                        κ3 : furtherFromOrigin(V
                                                                                     A −→ align                                                                                                                                               moveTowardsOrigin(P
                                                                                                                                                                                                                                        moveAwayFromOrigin(P
                                                                                                                                                                                                                                     moveAwayFromOrigin(P                                            , ,P          , Path)path)
                                                                                                                                                                                                                                                                                                              , ,Origin,
                        αα                                                                                                     1 ,Vβ24β, 4Path)                                                                                                                                            2 ,2P 1, 3P  3P1, 4P  4Path)
                          4 4: :∀C   ∀C   1 ,C
                                            1 ,C       : smallestCollection(C
                                                 2 2: smallestCollection(C                               1 )1 )                           : :∀∀OO    1 ,1O,O        : smallestWholeObject(O
                                                                                                                                                             2 2: smallestWholeObject(O                            1 )1 )                     → origin(Origin, path)
                                                                        κτ)4):: Q         −→       false                                                                     O  O   ) )                                              →→furtherFromOrigin(P
                                                                                                                                                                                                                                             furtherFromOrigin(P                         4 ,4P           , Path)
                                                                                                                                                                                                                                                                                                , 1P,1Path)
                              →→¬bigger(C
                                        ¬bigger(C             1 1 2 22 L(V1 ,V2 ) −→
                                                                 ,C  ,C                                                                    →  →     ¬bigger(O
                                                                                                                                                 ¬bigger(O                 ,
                                                                                                                                                                        11 22 ,
                                                                                   closerToOrigin(V1 ,V2 , Path)                                                                                                               γ4γ4: :∀∀P1P,1P, 2P,2Path  , Path: closestToOrigin(P
                                                                                                                                                                                                                                                                        : closestToOrigin(P                        1 )1 )
                                                                                                                                                                                                                                     →→(¬origin(P
                                                                                                                                                                                                                                             (¬origin(P             2 ,2Path)
                                                                                                                                                                                                                                                                         , Path)→→
                                                                          τ3 : P(V1 ,V2 ,V3 ) −→                                                                                                                                              ¬furtherFromOrigin(P
                                                                                                                                                                                                                                                 ¬furtherFromOrigin(P                              1 ,1P , 2P,2Path))
                                                                                                                                                                                                                                                                                                                  , Path))
                                                                                   moveAwayFromOrigin(V1 ,V2 ,V3 , Path)
                                               Figure 2:τ Developing                                          Arithmetic                from         Object            Collection               ,  Object          Constructionγ5γ5: :∀∀P1P,1and Origin,
                                                                                                                                                                                                                                                  , Origin,  MotionPath         :
                                                                                                                                                                                                                                                                      Path: Along                  a     Path
                                ρ1 : ∀V1 ,V2 : bigger(V                     4 : M(V                          3 ) −→ 2 ,V1 )
                                                                                                 ,V2 ,Vsmaller(V
                                                                                        1 ,V12 ) →                                                                                                                                   moveTowardsOrigin(P
                                                                                                                                                                                                                                        moveTowardsOrigin(P                          1 ,1P  , 1P,1Origin,
                                                                                                                                                                                                                                                                                                     , Origin,Path)      Path)
                                                                                   moveTowardsOrigin(V1 ,V2 ,V3 , Path)                                                                                                              →→origin(Origin,
                                                                                                                                                                                                                                             origin(Origin,Path)              Path)
                                ρ2 : ∀V1 ,V2 ,V3 : P(V1 ,V2 ,V3 ) → M(V3 ,V2 ,V1 )
                                                                          τ5 : A −→ true
                    grounding   ρ3 : metaphors.
                                            ∀V1 ,V2 ,V3 ,VThe               4 : (align(Voriginal               ) ∧ P(V2 ,V3 ,V4of
                                                                                                     1 ,V2descriptions                       )) the
                                                                                                                                                  → bigger(V
                                                                                                                                                          domains          4 ,V1 ) Generalising two domains
                                                                          τ6 : S −→ closestToOrigin
                                ρ     :     ∀V
                    are only4 given1 informally,     ,V   2    :   S(V      1 )   →      ¬bigger(V
                                                                                            but       we 1tried   ,V    )
                                                                                                                      2 to stay as closely to
                                                                          τ7 : Q(V            1 ) −→ origin(V1 , Path)                                                                    We tested various alternative formalisations, which all resulted
                    original as possible. One possible axiomatisation in H D T P                                                                                                           in HDTP being able to establish appropriate analogies. Here
                        ρ1ρ1: :∀V   ∀V  1 ,V1 ,V  2: bigger(V
                                                      : bigger(V
                                               2Collection                   1 ,V  ,V2 )2 )→
                                                                                1domain      →smaller(V
                                                                                                    smaller(V         2 ,V
                                                                                                                        2in 1 )1Table
                                                                                                                           ,V    )
                    of the    Object                                                                  is given                                 4. Such a for-                             we present axiomatisations of the grounded domains that are
                        ρ2ρ2: :∀V   ∀V  1  ,V
                                            1 ,V
                                               2  ,V
                                                  2  ,V
                                                      3   3 : P(V
                                                               :   P(V   1  ,V
                                                                            1  ,V2  ,V
                                                                                    2  ,V
                                                                                        3  )3 )→→M(V    M(V   3  ,V
                                                                                                                 3 ,V2 ,V
                                                                                                                        2 ,V1 )1 )
                    malisation specifies the vocabulary that is used in the form of                                                                                                        compact and consistent and that import integral parts of the
                        ρ3ρ3: :σ∀V  ∀V,V,V
                                   1 :1 1∀V    2 ,V   3 ,V
                                                     ,V
                                                  2and
                                                   1 ,V   32,V      4: : (align(V
                                                                :4 G(V       1 ,V2 ) →1and
                                                                                                 ,V
                                                                                                  L(V 2 )2then
                                                                                                          ∧,VP(V       2 ,V3 ,V4 )) →
                                                                                                                 1 ) provides
                                                                                                                                                 bigger(V4 ,V1 )
                    sorts,   entities                          predicates                                                                   facts        and laws
                          ρ4(align(V                        )∧        ):κ
                                                                     P(V                     4 )) bigger
                               :σ2∀V          ,V121,V : 2S(V              →      :¬bigger(V
                                                                             12 ,V    G
                                                                                      3 ,V −→             ,V2M(V  ) 3 ,V2 ,V1 )
                                                                                                                                                                                           domains. Furthermore, we demonstrate how the transfer of
                    to describe        :
                              → bigger(V    1∀V      ,V
                                             the structure 2  ,V   1
                                                        4 ,V1 ) κ : of
                                                                    3       P(V      1 ,V   2
                                                                                            the,V  3  ) 1→
                                                                                                      domain.               For       example,                axiom
                                                                             2 L −→ smaller                                                                                                knowledge from one domain to another one works, because
                    α3 ρstates
                          4 : ∀V
                                σ3 that:1 ,V ∀V    : ,V
                                               2 1if  S(V  2 ,V
                                                         two   1 )3→
                                                                       ,V        : (A(V1 ,V12C
                                                                             4¬bigger(V
                                                                       collections                      )∧
                                                                                                        ,V     P(V
                                                                                                               )
                                                                                                               and     2 ,V
                                                                                                                          C  32,Vcan4 )) → be    G(V     4 ,V1 ) i.e.
                                                                                                                                                  aligned,
                                                                          κ3 : A −→ align                  12                                                                              this is a hallmark of ‘interesting’ analogies.
                    all theirσobjects
                                   4 : ∀V1 ,V           can2 : S(V    beκ14)paired → (¬Q(V2 )and
                                                                                 : Q −→up,
                                                                                                             → ¬G(V1 ,V2 ))
                                                                                                     false C4 is created by putting                                                             In a first step, we generalise the domains of Object Collec-
                    C2 and C     λ13: together,
                                             P −→ combine             then C4 will be bigger than C1 . Note that                                                                           tion and Object Construction. (We only use the basic version of
                          σ1 : ∀V1 ,V2 : G(V1 ,V2 ) → L(V2 ,V1 )
                    further      λformulae
                                    2 : M −→ need             split to be added to get a complete axioma-                                                                                  the Object Construction domain here, which largely resembles
                        σσ  2 :∀V
                          1: λ
                    tisation,        ∀V,V
                                    3but
                                              ,V2: ,V
                                        :1 1S such
                                                2−→   G(V       : P(V
                                                               formulae      1 ,V2 ,V3can
                                                           3smallestWholeObject
                                                                  1 ,V2 ) → L(V
                                                                                               ) ,V
                                                                                                  → M(V
                                                                                               2 1easily ) 3 ,Vbe                )
                                                                                                                        2 ,V1introduced                    into the                        Object Collection. This version is not sufficient to introduce the
                          σ     :
                        σ2 3: τas    ∀V
                                   1 :1long
                                              ,V
                                            G(V
                                            1 ,V     ,V
                                                   2 ,V3:2P(V ,V ) −→   :
                                                                    4 ,V ,V (A(V         ,V
                                                                                       1 2       ) ∧    P(V     2,V 3,V 4) → G(V4 ,V1 )
                                                                                                                  ,V     ,V     ))
                    system        ∀V       ,V   2 1as  3 some                     2 3 ) → M(V3consistency
                                                                         1 elementary                                 2 1                   constraints are                                concept of fractions.) The axiomatisation of the two domains
                                          furtherFromOrigin(V                                           path)
                        σσ                  1 ,V2 : S(V1:)(A(V            → (¬Q(V               2 )2P(V                     ))2 ))
                            4 : ∀V                                                          1 ,V     ,→     ¬G(V        1 ,V
                          3 : ∀VWhile
                    satisfied.           1 ,V2 ,V3 ,V      adding4                  1 ,V2 ) ∧formulae
                                                                                    more                     2 ,V3 ,V4to         →this G(V      4 ,V1 )
                                                                                                                                             formalisation                                 can be found in the two boxes in the bottom left of figure 2.
                                τ2 : L(V1 ,V2 ) −→
                        σ
                    might    :    ∀V
                          4 strengthen     ,V   2  :  S(V
                                         1closerToOrigin(V    the
                                                                1  )  →       (¬Q(V
                                                                          support               )  →
                                                                                                 for a specific
                                                                                    1 ,V2 ,2 path)
                                                                                                         ¬G(V           ,V     ))
                                                                                                                      1 2 alignment, it does                                              The grounded domains are restricted to the operations that in
                    not necessarily
                                τ3 : P(V1 ,V           introduce
                                                             2 ,V3 ) −→ new mappings of concepts to other
                                                                                                                                                                                                                                                                           2f                             g
                                                                                                                                                                                           arithmetic correspond to greater, less, addition and subtrac-
                                          moveAwayFromOrigin(V                                        ,V2α,V63,, which path) states the transi-
                    domains. An                    example for this1is                                                                                                                     tion. The axioms αi and βi (for i                                                        1; : : : ; 4 ) correspond to
                    tivityτ1of :τ4G(V : M(V
                                     bigger. 1 ,V21),V
                                 furtherFromOrigin(V
                                                           −→ 2 ,V3 ) −→
                                                             This             formula
                                                                                    1 ,V2 ,1Path)
                                                                                                     embeds                bigger further in the                                           each other and are generalised in the obvious way by intro-
                                          moveTowardsOrigin(V                                    ,V2 ,V3 , path)
                        τ1 : G(V
                    structure         of   1 ,V
                                              the2 ) −→ domain                     but      does          not       introduce               new concepts.
                          τ2 furtherFromOrigin(V
                               :τ5L(V : A1 ,V      2 ) −→ true                                                                                                                             ducing individual variables and variables for operations. For
                                                −→                               1 ,V2 , Path)
                    putTogether, closerToOrigin(V
                                                takeAway,1 ,V                   bigger
                                                                                    2 , Path)      and       smaller             are     considered                 core                   example, the predicate putTogether of the Object Collection
                        τ2 : τL(V  6 : 1S   ,V−→ 2 ) −→  closestToOrigin
                          τ3 closerToOrigin(V
                    concepts   : P(V of 1the   ,V     ,V
                                                    2 3Object  )    −→        Collection                 domain.               In    what         follows,              we
                                τmoveAwayFromOrigin(V
                                   7 : Q(V1 ) −→ origin(V              1 ,V2 , Path)       11,,Vpath)                                                                                      domain is identified with combine of Object Construction and
                                                                                                   2 ,V3to   , Path)
                    willτ3restrict
                            : P(V1 ,V2 ,V3 ) −→our
                          τ4 moveAwayFromOrigin(V
                               : M(V1 ,V2 ,V3 ) −→
                                                            axiomatisations                                        such         simple            versions                in               generalised to a variable P. The substitutions µ1 and λ1 can be
                    which      just         the      cores              of       the        ,V
                                                                                           domains ,V     , Path)  are      represented                  and         con-
                                 moveTowardsOrigin(V11,V22,V33, Path)                                                                                                                      used to reconstruct the original expressions. Note that aligning
                        τ4 : M(V
                    nected                 1 ,V2 ,Vother.    ) −→ Furthermore, we will omit technical
                               : to        each
                          τ5 moveTowardsOrigin(V
                                   A −→            true3                                                                                                                                   corresponding clauses in formalisations is only done for the
                                                                                    1 ,V2 ,V3 , Path)
                    details     as     well         as       the        specification                       of sorts and signatures for a
                        τ5τ6: :κA1S−→ :−→   Gtrue closestToOrigin
                                                 −→          bigger                                                                                                                        convenience of the reader; H D T P does not rely on such an
                    moreτ7concise                  presentation.
                               : Q(V1 ) −→ origin(V1 , Path)                                                                                                                               ordering to find the best possible analogical mapping.
                        τ6 : κ  S2−→  : LclosestToOrigin
                                                 −→ smaller
                        τ7 : κ  Q(V3 : 1A    ) −→−→ origin(Valign 1 , Path)
                                κ4 : Q −→ false
                          κ1 : G −→ bigger
                        κ1κ2: :GL−→       −→bigger smaller
                          κ 3  :    A
                        κ2 : L −→ smaller −→       align
                          κ 4  :    Q
                        κ : A −→ align     −→       false
                          3                                                                                                                                                     1995
                        κ4 : Q −→ false

                                                                                for refinement. It indicates that an elaborated version of ρ4
    Table 4: Formalisation of the Object Collection domain
                                                                                might be used to describe Arithmetic-1, namely
                                                                                            8
                                                                                      ρ04 : V1 ; V2 : S(V1 ) ! :Q V ! :bigger V
   Sorts
       coll                                                                                                     (    ( 2)                 ( 1 ; V2 ))
   Entities
       singleton : coll
   Predicates                                                                   which mainly states that if V1 is the smallest number, then
       smallestCollection : coll                                                either V2 is Z E R O or V1 is not bigger than V2 . This new predi-
       bigger : coll  coll
       smaller : coll  coll
                                                                                cate Q can also be used for the transfer of additional formulae,
       equal : coll  coll                                                      e.g. γ5 can be introduced into Arithmetic-1 resulting in
       putTogether : coll  coll  coll
   Laws
       takeAway : coll  coll  coll                                                                 8
                                                                                                ρ5 : V1 ; O : M (V1 ; V1 ; O) !Q O    ( )
     α1 : 8 C1 : coll; C2 : coll :
            bigger(C1 ; C2 ) ! smaller(C2 ; C1 )
                                                                                basically saying V1 minus V1 equals Z E R O . Thereby, the basic
     α2 : 8 C1 : coll; C2 : coll; C3 : coll :                                   ideas on Z E R O are incorporated into Arithmetic-1 by refine-
            putTogether(C1 ; C2 ; C3 ) ! takeAway(C3 ; C2 ; C1 )                ment and transfer from the Motion Along a Path domain.
     α3 : 8 C1 : coll; C2 : coll; C3 : coll; C4 : coll :
            align(C1 ; C2 ) ^ putTogether(C2 ; C3 ; C4 ) ! bigger(C4 ; C1 )              Goguen’s notion of concept blending
     α4 : 8 C1 : coll; C2 : coll :
            smallestCollection(C1 ) ! not(bigger(C1 ; C2 ))                     Another important means to create new mathematical con-
     α5 : 8 C1 : coll; C2 : coll :                                              cepts is concept blending, in particular in the form presented
            equal(C1 ; C2 ) ! (:bigger(C1 ; C2 ) ^:smaller(C1 ; C2 ))           by Goguen (2006). His figure 3, reproduced below, gives
     α6 : 8 C1 : coll; C2 : coll; C3 : coll :                                   an overview. Each node in this graph corresponds to a con-
            (bigger(C1 ; C2 ) ^ bigger(C2 ; C3 )) ! bigger(C1 ; C3 )
                                                                                ceptual space in the sense of Gärdenfors (2000), which,
     :::
                                                                                roughly speaking, is a subset of the system’s knowledge.
   Facts                                                                        The arrows preserve the infer-
     α7 : smallestCollection(singleton)                                         ential structure from space to                              G?
     :::
                                                                                space, and the diagram commutes.                               ??
                                                                                                                                                 ??
                                                                                Goguen does not discuss exam-                                      ??
                                                                                                                                                    ?
Refining the generalisation                                                     ples from arithmetic, but how from            I1 @                        I2
                                                                                the concepts H O U S E and B O AT                   @@                ~~
The formulae computed above by generalising Object Collec-                                                                            @@            ~~
                                                                                the concepts H O U S E B O AT and                       @@        ~~
tion and Object Construction serve as a first formalisation of                                                                            @  ~
                                                                                                                                                ~
                                                                                B O AT H O U S E are created by con-
elementary arithmetic (labelled Arithmetic-1 in figure 2). The                                                                              B
                                                                                cept blending. The G space con-
variables introduced by anti-unification are regarded as enti-                  tains generic elements, such as
ties and predicates of this new domain. Because the grounded                    P E R S O N or O B J E C T ; the I spaces represent more specific
domains chosen were very similar, and in particular because                     conceptual spaces, in his example I1 represents that a H O U S E
the grounded domains neither have the concept E M P T Y C O L -                 is on L A N D and that a P E R S O N L I V E S in it and I2 that
L E C T I O N nor E M P T Y C O N S T R U C T I O N , the system com-
                                                                                a PA S S E N G E R R I D E S in a B O AT and that the B O AT is
putes only a subtheory of arithmetic that lacks a neutral el-                   on WAT E R . Concept blending takes these conceptual spaces
ement with respect to the operation P (representing A D D I -                   and maps them into another space (the B space) in a way that,
T I O N ). A second step of creating analogical mappings is
                                                                                for example, that the B O AT is mapped onto the P E R S O N
needed to transfer the concept Z E R O from a differently struc-                L I V I N G in a H O U S E , resulting in the concept of a house in
tured domain into our Arithmetic-1. This is achieved by the                     which the boat ‘lives’ – a B O AT H O U S E .
second generalisation between the formalisation of Motion                          Fauconnier and Turner (2002, pp. 242–245) discuss blends
Along a Path and Arithmetic-1 resulting in Arithmetic-2 de-                     in arithmetic. Their presentation can be formulated in the form
picted in figure 2.                                                             suggested by Goguen (they are a major influence on Goguens
    The formalisation we chose for Motion Along a Path is dif-                  conception in the first place), thus giving an extension to the
ferent from the other domains in that the predicates take an                    work described in this paper. For example, Lakoff and Núñez’s
extra argument, path, to indicate the path along which the mo-                  extended version of the motion along a path metaphor supports
tion occurs. As a consequence, higher-order anti-unification                    an analogue of the rational numbers. Taking this as I2 and
is applied which leads to the slightly more complex substi-                     object collection as I1 , a generalisation G can be found as
tutions τ1 to τ7 and κ1 to κ4 . As before, these substitutions                  above, which ignores the division operation of I2 . Forming
can be used to reconstruct the source and target domains from                   the blend B then allows the extra operation to be incorporated
the generalisation. A further point to note is that γ4 contains                 into a conceptualisation which respects the generalisation. The
an additional condition in comparison to ρ4 . This mismatch                     blend can be seen as an updated view of I1 :
is handled by introducing a generalised predicate Q, which
is mapped to false by κ4 and therefore can be neglected in                         Once we have the blend, and reify it, we can adopt the
Arithmetic-1. However, this dummy predicate is used as a hint                      view that the previous conception of number was ‘miss-
                                                                            1996

   ing’ several numbers that were ‘there’ but not yet ‘dis-                               Acknowledgments
   covered’. (Fauconnier & Turner, 2002, p. 244)                      The research reported here was supported by E P S R C grant
                                                                      EP/F035594/1 for the Wheelbarrow project.
              Conclusions and future work                                                     References
We examined to which extent the cognitive processes underly-          Barwise, J., & Seligman, J.(1997). Information flow: The logic
ing mathematical thinking can be made formally precise and              of distributed systems. Cambridge: Cambridge University
algorithmically operationalised. For this purpose we took the           Press.
mathematical metaphors of Lakoff and Núñez (2000) and used          Fauconnier, G., & Turner, M. (2002). The way we think:
the analogy engine H D T P to compute generalisations from              Conceptual blending and the mind’s hidden complexities.
the basic source domains of arithmetic based on higher-order            New York: Basic Books.
anti-unification.                                                     Gärdenfors, P. (2000). Conceptual spaces: The geometry of
   For this, we used formalisations similar to the ones in our          thought. Cambridge, MA: M I T Press.
earlier approaches using Information Flow theory and created          Gentner, D. (1983). Structure-mapping: A theoretical frame-
a first generalisation that contained the fundamental concepts          work for analogy. Cognitive Science, 7(2), 155–170.
of arithmetic. We extended the first generalisation produced          Gentner, D., Bowdle, B. F., Wolff, P., & Boronat, C. (2001).
by H D T P by incorporating a transfer of concepts, which               Metaphor is like analogy. In D. Gentner, K. J. Holyoak, &
added new concepts to the ‘growing’ domain of arithmetic (in            B. N. Kokinov (Eds.), The analogical mind: Perspectives
our case the idea of a neutral element). Thus, anti-unification         from cognitive science (p. 199-253). Cambridge, MA: MIT
cannot only serve to find abstractions of two source domains            Press.
but also to transfer concepts.                                        Gentner, D., & Markman, A. B. (1997). Structure mapping
   We also briefly described, how Goguen’s concept blending             in analogy and similarity. American Psychologist, 52(1),
is a direct extension of the HDTP approach. A paper detailing           45–56.
the role of concept blending for arithmetic and a treatment           Goguen, J. (2006). Mathematical models of cognitive space
within the H D T P framework is currently submitted.                    and time. In D. Andler, Y. Ogawa, M. Okada, & S.Watanabe
   The demonstrated generalisation examples are still quite             (Eds.), Reasoning and Cognition: Proceedings of the Inter-
simple. Enriching the domains to get more interesting transfer          disciplinary Conference on Reasoning and Cognition (pp.
candidates is therefore the next step. This notion of ‘interest-        125–128). Keio University Press.
ingness’ is central to a comprehensive treatment of mathemati-        Guhe, M., Pease, A., & Smaill, A. (2009). A cognitive model
cal discovery, because there is an unlimited number of possible         of discovering commutativity. In Proceedings of the 31st
theorems and theories, but only a fraction of these are deemed          Annual Conference of the Cognitive Science Society. Austin,
interesting and useful enough for mathematicians to consider.           TX: Cognitive Science Society.
For automated theorem provers, this is a hard problem; one            Guhe, M., Smaill, A., & Pease, A. (2009a). A formal cogni-
on which we expect the heuristic nature of the HDTP engine              tive model of mathematical metaphors. In B. Mertsching,
will shed more light.                                                   M. Hund, & Z. Aziz (Eds.), KI 2009: Advances in Artificial
   The grounded domains as we used them here are already                Intelligence (pp. 323–330). Berlin: Springer.
generalisations of concrete situations, e.g. for the object collec-   Guhe, M., Smaill, A., & Pease, A. (2009b). Using Informa-
tion domain the person/system must already have abstracted              tion Flow for modelling mathematical metaphors. In Pro-
over concrete instances of the acts of putting collections to-          ceedings of the 9th International Conference on Cognitive
gether and realised that this is a general law holding in this          Modeling.
domain. H D T P should be suited to create these abstractions         Krumnack, U., Schwering, A., Gust, H., & Kühnberger, K.-U.
as well. A more pressing and fundamental case seems to be,              (2007). Restricted higher-order anti-unification for analogy
however, to create an abstract, generalised number concept              making. In AI 2007: Advances in Artificial Intelligence (pp.
that extends beyond the subitising range, i.e. those cardinal-          273–282). Berlin: Springer.
ities (ranging from one to three or four) for which humans            Lakatos, I. (1976). Proofs and refutations: The logic of mathe-
don’t need to count but immediately perceive the number of              matical discovery. Cambridge: Cambridge University Press.
objects and which seem to be innate.                                  Lakoff, G., & Núñez, R. E. (2000). Where mathematics comes
   Some other directions in which to extend our work are: (1)           from: How the embodied mind brings mathematics into
How are the results influenced by the order of generalisation?          being. New York: Basic Books.
(2) How can the object construction domain be extended such           Plotkin, G. D. (1970). A note on inductive generalization.
that fractions (rational numbers) can be introduced into the            Machine Intelligence, 5, 153–163.
domain of arithmetic? (This is Lakoff and Núñez’s fraction          Schwering, A., Krumnack, U., Kühnberger, K.-U., & Gust,
extension of the basic metaphor.) (3) How can our approach              H. (2009). Syntactic principles of Heuristic-Driven Theory
be extended to include Lakoff and Núñez’s linking metaphors,          Projection. Journal of Cognitive Systems Research, 10(3),
which are used for creating more abstract mathematical con-             251–269.
cepts.
                                                                  1997

