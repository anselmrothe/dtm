UC Merced
Proceedings of the Annual Meeting of the Cognitive Science
Society
Title
Mathematical reasoning with higher-order anti-unifcation

Permalink
https://escholarship.org/uc/item/4w0023k9

Journal
Proceedings of the Annual Meeting of the Cognitive Science Society, 32(32)

Authors
Guhe, Markus
Pease, Alison
Smail, Alan
et al.

Publication Date
2010-01-01
Peer reviewed

eScholarship.org

Powered by the California Digital Library
University of California

Mathematical reasoning with higher-order anti-unifcation
Markus Guhe, Alison Pease, Alan Smaill
(m.guheja.peaseja.smaill@ed.ac.uk)
University of Edinburgh, School of Informatics, Informatics Forum, 10 Crichton Street, Edinburgh E H 8 9 A B, Scotland

Martin Schmidt, Helmar Gust, Kai-Uwe Kühnberger, Ulf Krumnack
(martischjhgustjkkuehnbejkrumnack@uni-osnabrueck.de)
University of Osnabrück, Institute of Cognitive Science, Albrechtstr. 28, 49076 Osnabrück, Germany
Abstract
We show how heuristic-driven theory projection (H D T P, a
method based on higher-order anti-unification) can be used to
model analogical reasoning in mathematics. More precisely,
H D T P provides the framework for a model of the inductive
analogy-making process involved in establishing the fundamental concepts of arithmetic. This process is a crucial component
for being able to generalise from the concrete experiences that
humans have due to their embodied and embedded nature. Such
generalisations are a cornerstone of the ability to create an abstract domain like arithmetic. In addition to generalisations,
H D T P can also transfer concepts from one domain into another, which is, for example, needed to introduce the concept
Z E R O into arithmetic. The approach presented here is closely
related to the theories of Information Flow and Institutions.
The latter in particular provides a compelling way to integrate
concept blending into the HDTP approach.
Keywords: mathematical cognition; mathematical reasoning;
analogy; anti-unification; concept blending

Mathematical reasoning as a cognitive process
Although mathematics is usually presented in terms of axioms,
concise proofs, theorems and so on, the actual cognitive process of mathematical reasoning is very different. For example,
when a mathematician changes a definition this affects the
proofs that use it, but such changes are not discussed in mathematical papers. Additionally, mathematics, at least partly, does
not consist of discovering eternal, Platonic ideals but in creating mathematical concepts. For example, Lakatos’s (1976)
account of the history of Euler’s conjecture illuminates how
the concept P O LY H E D R O N can differ and how its definition
depends on the current circumstances and needs of the mathematician. Put differently, if the Platonic ideal P O LY H E D R O N
does exist, it is not clear how it can be identified by mathematical means – what cognitive processes mathematicians can use
to find the correct definition. Thus, mathematical concepts are
not necessarily the same as the ideals.
Lakoff and Núñez (2000) describe how our embodied, situated experience is the basis on which abstract mathematical
concepts are developed by a process of metaphorical abstraction and transfer. In chapter 3, they describe how basic arithmetic is created from four everyday experiences, which are
the source domains of the metaphors. In this way, arithmetic
is grounded in situated cognition. To motivate that these four
domains in particular are source domains, Lakoff and Núñez
analyse linguistic expressions used in the target domain, arithmetic, which they trace back to these four domains. For example, we use the terms add and take away in arithmetic. Lakoff
and Núñez argue that these terms were originally used for

talking about collections of objects, such as physically placing
an object into a container, e.g. adding an onion to the soup, or
physically removing a substance or an object from a container,
e.g. take a book out of the box.
Analogical reasoning is a central component of the process transforming knowledge of this kind into mathematical
concepts. For present purposes we assume that metaphor and
analogy are essentially the same cognitive process (Gentner,
Bowdle, Wolff, & Boronat, 2001), and we have demonstrated
how structure mapping (Gentner, 1983; Gentner & Markman,
1997) – a basic method to compute analogical relations – can
account for the overall cognitive process (Guhe, Pease, &
Smaill, 2009).
In this paper, we describe a formal cognitive model of this
process. This has a twofold motivation: firstly, we want to specify the cognitive processes that mathematicians use, to better
understand how mathematical discovery works; secondly, we
want to use the model to improve automated theorem provers
by incorporating cognitive mechanisms. In Guhe, Smaill, and
Pease (2009a, 2009b) we presented formal representations of
the four grounding metaphors (the 4Gs) and suggested how
Information Flow theory (Barwise & Seligman, 1997) may be
used to model the analogies involved. The 4Gs are: (1) arithmetic is object collection, (2) arithmetic is object construction,
(3) measuring stick and (4) arithmetic is motion along a path.
Here, we present a proof-of-concept of how performing
anti-unification (Plotkin, 1970) on such representations can
account for aspects of the analogical reasoning involved in
the 4Gs. This inductive kind of reasoning provides us with a
procedural version of the otherwise static Information Flow
models and enables us to computationally determine the relationships between the domains (classifications in the case
of Information Flow). More precisely, we will use HeuristicDriven Theory Projection (H D T P; Schwering, Krumnack,
Kühnberger, & Gust, 2009), a general framework for making
analogies. H D T P provides us with the means to generalise
over two of Lakoff and Núñez’s domains to establish a basis
for arithmetic as well as the means to generalise over one of
the domains as source domain and arithmetic as the target
domain to add concepts to arithmetic that are only present in
one of the grounding domains. We will also outline how this
conception of mathematical reasoning is linked to Goguen’s
(2006) notion of concept blending (which is based on notions
by Gärdenfors, 2000 and Fauconnier & Turner, 2002), a further cognitive process for creating mathematical concepts.

1992

Metaphors for arithmetic

Table 2: Arithmetic is object construction metaphor (Lakoff &
Núñez, 2000, pp. 65–66)

Arithmetic is object collection

object construction
objects
smallest whole object
size of object
bigger
smaller
constructed object

arithmetic
numbers
the unit (one)
size of number
greater
less
result of arith.
operation
a whole number
addition

The arithmetic is object collection metaphor (Table 1) is based
on the notion that the repeated manipulation of (small, countable, physical) collections of objects lets us notice certain
regularities. For example, we can determine which one of two
collections is bigger by aligning the objects in the two collections one-to-one, and the collection that has at least one
unpaired object left over is the bigger collection. (Smaller
and equal are, of course, determined correspondingly.) This
corresponds to the (abstract) arithmetic notion G R E AT E R .
By comparing collections of objects in this way we can
also group such collections into groups of collections of equal
size, i.e. where after the aligning procedure no object is left
unpaired. Each of these groups corresponds to a number in
arithmetic.
There are two things to note about this basic metaphor.
Firstly, it does not produce a concept of Z E R O , because the
empty collection is a collection that does not exist physically.
(Even calling one object a collection with one object is an
abstraction of the term collection.) Lakoff and Núñez (2000,
p. 64) propose that an entity-creating metaphor is required to
create a concept that is not part of the basic metaphor (like
Z E R O ). This corresponds well with the fact that, historically,
Z E R O was a rather late invention. Secondly, the subtraction
operation requires that a smaller collection be taken from a
bigger one, because physically, negative objects do not exist.1

The motion along a path metaphor (Table 3) adds concepts
to arithmetic that we experience by moving along straight
paths. Numbers are point locations on paths. Addition and
subtraction correspond to a movements from point one point
on the path to another point on the path. An important new
concept that is added to arithmetic by this metaphor is Z E R O ,
which is based on the concept of a path’s origin and which
provides a direction for the movements along paths, namely
towards the origin or away from it.

Table 1: Arithmetic is object collection metaphor (Lakoff &
Núñez, 2000, p. 55)

Table 3: Arithmetic is motion along a path metaphor (Lakoff
& Núñez, 2000, p. 72)

object collection
collections of objects of the same size
size of collection
bigger
smaller
smallest collection
putting collections together
taking a smaller collection from a
larger collection

whole object
putting objects together to form
larger objects
taking smaller objects from larger
objects to form other objects

Arithmetic is motion along a path

arithmetic
numbers
number
greater
less
the unit (one)
addition
subtraction

motion along a path
acts of moving along the path
a point location on the path
origin; beginning of the path
unit location, a point location distinct
from the origin
further from the origin than
closer to the origin than
moving away from the origin a
distance
moving toward the origin a distance

Arithmetic is object construction
The arithmetic is object construction metaphor (Table 2) runs
along the same lines, except that it is not based on collections
of objects, but on objects that are constructed from smaller
objects. In this way, fractions are added to arithmetic, although
they are not part of the basic metaphor. Consider, for example,
an object that is constructed out of seven smaller objects. If
now a smaller object that consists of three of the seven overall
objects is removed from the original object, the two resulting
objects have a size of 73 and 47 of the original.
1 One is reminded of the old joke: If on one floor 5 people leave
an elevator containing 3 people, 2 people have to enter the elevator
on the next floor in order for it to be empty.

subtraction

arithmetic
arith. operations
result of an operation; number
zero
one
greater
less
addition
subtraction

Heuristic-Driven Theory Projection
Overview
This section provides a short overview of the basic ideas of
heuristic-driven theory projection (H D T P), a formal framework to model analogical mapping and reasoning. A more
detailed description can be found in Schwering et al. (2009).
H D T P establishes analogies between two domains, the
source and the target, by detecting common structures. In the
mapping phase, source and target are compared for structural
commonalities and a generalised description is created, which

1993

subsumes the matching parts of both domains. In the transfer
phase, unmatched knowledge in one domain can be mapped
to the other to establish new hypotheses.
H D T P is a formal framework that computes analogical
relations and inferences for domains represented in first-order
logic. Both, source and target domain, are given by axiomatisations, i.e. finite sets of first-order formulae. The basic idea
is to associate pairs of formulae from the domains in a systematic way. H D T P uses anti-unification (Plotkin, 1970) to
identify common patterns in formulae. In anti-unification, two
formulae are compared and the least general generalisation
that subsumes both formulae is identified.
Figure 1 provides some examples of anti-unification of
terms. Terms are generalised to an anti-instance where different constants or function symbols are replaced by a variable.
In (i), first-order anti-unification is sufficient. However, the
terms in (ii) differ in the function symbols, i.e. first-order
anti-unification fails to detect structural commonalities. Here,
higher-order anti-unification generalises function symbols to a
variable and retains the structural commonality. It is even possible to generalise terms in which common parts are embedded
structurally in a different way, as shown in (iii).2 Substitutions
accompanying the generalised terms are created, which can be
used to reconstruct the original terms.
F (a)

f (X )

**
 ** X b
X a
**




!

!

f (a)

f (b)

(i)

F

!

*
 **
f  * F g
**




!

f (a) g(a)
(ii)

F

!f

F (a; b)


f (a; b)

!

66
66F (x;y)
66h(x;g(y))


h(a; g(b))
(iii)

Figure 1: Anti-unification of terms
H D T P extends this classical anti-unification of terms to
formulae and logical theories by iteratively picking pairs of
formulae to be generalised from the domains. This process
is driven by heuristics. Coherent mappings are preferred, i.e.
mappings in which substitutions can be reused. The generalised theory together with its substitutions specifies the analogical relation between source and target. Additional information about the source domain, i.e. formulae with no correspondence in the target domain, can be transferred by replacing
symbols using the established substitutions.

Modelling the arithmetical metaphors
H D T P provides two different ways in which Lakoff and
Núñez’s (2000) grounded domains (Object Collection, Object
Construction etc.) can be related to the abstract domain of Arithmetic. Following Lakoff and Núñez, the grounded domains
constitute the source, while Arithmetic is the target domain.
To establish an analogical relation between Object Collection
and Arithmetic, HDTP can construct a generalisation of these
2 HDTP

uses a restricted form of higher-order substitutions, that
allows to expand terms by introducing arguments and nested structures as described in Krumnack, Schwering, Gust, and Kühnberger
(2007).

domains:
Generalisation
G

r
GG
rr
GG
rr
GG
r
GG
rr
r
x
r
#
analogical
/
o
Object Collection
Arithmetic
relation

In this model, both domains are already given. The analogy
explains abstract concepts like numbers by linking them to
familiar entities from the grounded domains. Thus, the generalisation provides a description of the commonalities of the
grounded and the abstract domains.
However, from the cognitive perspective, Arithmetic does
not initially exist – it has to be created by an act of abstraction
as well. This idea can be modelled by analogically relating
two grounded domains, e.g. Object Collection and Object Construction. Arithmetic then emerges as a generalisation of these
domains.
Generalisation
(Arithmetic
JJ)
v
vv
vv
vv
v
z
v
Object Collection

JJ
JJ
JJ
J%
Object Construction

In our view, a combination of both approaches is needed to
model the cognitive bootstrapping process. By generalising
over two grounded domains, an abstract domain is established, which serves as a ‘proto-domain’ of Arithmetic, i.e.
a domain that already contains some arithmetical concepts.
This is then refined subsequently, by relating it analogically
to other grounded domains, removing peculiarities of the two
original domains and/or adding new concepts by analogical
transfer.
Generalisation
(Arithmetic-2
; )
x
;;
;;
;;
;;
;;
;;
DD
transfer
;;
DD
"
) ;
Motion
Object
Along a Path
Construction
x
xx

|xx
Generalisation
(Arithmetic-1
DD )i






Object
Collection

It should be noted that in pursuing this approach the results
may vary depending on which grounded domains are chosen
for generalisation and on the order in which other grounded
domains are added for refinement. This is due to the heuristics
that HDTP applies when building up the generalisation. The
more similar the grounded domains are, the richer the generalisation will be, while dissimilar domains give coarser results.
Nevertheless, we expect that this effect can be compensated
by further mapping the initial generalisation to other domains.
A detailed examination of this will be a focus of our future
work.

Formalisation of domains
We demonstrate the feasibility of the outlined approach by
applying it to simple formalisations of Lakoff and Núñez’s

1994

σ1 : ∀V1 ,V2 : G(V
ρ1 : →
∀V1 ,V2 : bigger(V
)
1 ,V2 ) → L(V2 ,V1 ) 1 , P2 , Path)
P(V1 ,V2 ,V
2 ,V
,C1 ) 1 ,V2 )τ→
→ smaller(O2 , O1 )
furtherFromOrigin(P
3 : smaller(V
3 )1−→
τ2 : smaller(C
L(V1 ,V2 )2−→
moveAwayFromOrigin(V
,V2 ,V3 , Path)
→
closerToOrigin(P
P12,,V
Path)
1
σ
:
∀V
,V
,V
:
P(V
ρα22:: ∀V
,V
,V
:
P(V
,V
)
→
M(V
,V
,V
)
2
1
2
3
1 ,V2 ,V3 ) → M(V23,,V
1)
closerToOrigin(V
,V
,
Path)
3 3 : putTogether(C
1 12 23
3 32) 1
∀C11 ,C2 2 ,C
β2 : ∀ O1 , O2 , O3 : combine(O1 , O2 , O3 )
1 ,C2 ,C
τ4 ,V
: M(V
,V2 ,V
),V−→
Abstract
→
takeAway(C
,C
,C
)
→
split(O
,
O
,
O
)
γ
:
∀
P
,
P
,
P
,
Path
:
1
3
σ
:
∀V
,V
,V
,V
:
(A(V
,V
)
∧
P(V
,V
,V
)) → G(V4 ,V
3
2
1
3
2
1
2
1
2
3
ρ
:
∀V
,V
,V
,V
:
(align(V
)
∧
P(V
,V
))
→
bigger(V
,V
)
3
1
2
3
4
1
2
2
3
4
τ
:
P(V
,V
,V
)
−→
3 3Metaphors
1 21 32 43
1 2
2 3 4
4 1
Formalization of the Arithmetic
moveTowardsOrigin(V
moveAwayFrom(P1 , P2 , P3 , Path)
2 ,V3 , Path)
moveAwayFromOrigin(V
,V,V
,V)3 , Path) β3 : 1∀,V
α
:
∀C
,C
,C
,C
:
O
,
O
,
O
,
O
:
1
2
σ
:
∀V
,V
:
S(V
)
→
(¬Q(V
)
→
¬G(V
,V
3
1
2
3
4
1
2
3
4
ρ
:
∀V
,V
:
S(V
)
→
¬bigger(V
4
1
2
1
2
1
2
4
1 2
1
2
to be Collection
filled . . .
→ moveTowardsOrigin(P1 , P))
bject
2 , P3 , Path)
τ5 : A1 −→
,C ) ∧ putTogether(C
,C4 ))
(align(O1 , O2 ) ∧ combine(O2 , O3 , O4 ))
2 ,C3true
τ(align(C
4 : M(V11 ,V22,V3 ) −→
Keywords:
Mathematical Cognition; Analogies;
AntiObject Construction
→ bigger(C
,C
)
→
bigger(O
,
O
)
γ
:
∀
P
,
P
,
P
,
P
,
Path
:
4
1
4
1
3
1
2
3
4
τ
:
S
−→
closestToOrigin
moveTowardsOrigin(V61 ,V2 ,V3 , Path)
Unification
moveAwayFromOrigin(P2 , P3 , P4 , Path)
Motion Along A Path
α4 τ: 5 ∀C
smallestCollection(C
β4 1: , Path)
∀ O1 , O2 : smallestWholeObject(O1 )
2 : true
τ7 : Q(V11)) −→ origin(V
: A1 ,C
−→
→ furtherFromOrigin(P4 , P1 , Path)
→ ¬bigger(C1 ,C2 )
→ ¬bigger(O1 , O2 )
aaaa
τ6Metaphors
: S −→ closestToOrigin
γ
:
Formalization of the Arithmetic
4
τ1 : G(V1 ,V2 ) −→∀ P1 , P2 , Path : closestToOrigin(P1 )
σ1 : ∀V1 ,V2 : G(V1 ,V2 ) → L(V2 ,V1 )
→ (¬origin(P
2 , Path) →
τ7 : Q(V1 ) −→ origin(V1 , Path)
furtherFromOrigin(V
1 ,V2 , path)
bject Collection
¬furtherFromOrigin(P
1 , P2 , Path))
Generalisation σ2 : ∀V1 ,V2 ,V3 : P(V1 ,V2 ,V3 ) → M(V3 ,V2 ,V1 )
τ2 : L(V1 ,V2 ) −→
Object Construction
γ
:
∀
P
,
Origin,
Path
:
1
5
2 ) ∧ P(V2 ,V3 ,V4 )) → G(V4 ,V1 )
(Arithmetic-2) σ3 : ∀V1 ,V2 ,V3 ,V4 : (A(V1 ,V
closerToOrigin(V1 ,V2 , path)
κ1 : G −→ bigger
moveTowardsOrigin(P
Motion Along A Path
Abstract
1 , P1 , Origin, Path)
σ4 : ∀V1 ,V2 : S(V1 ) → (¬Q(V2 ) → ¬G(V1 ,V2 ))
aaaa
τ
:
P(V1 ,V2 ,V3 )→
−→
origin(Origin, Path)
3
κ
:
L
−→
smaller
2
aaaa
Generalisation
moveAwayFromOrigin(V
1 ,V2 ,V3 , path)
to be filled . . .
κ3 : A −→ align
κ1 : G −→ bigger
(Arithmetic-1)
τ4 : M(V
1 ,V2 ,V3 ) −→ Mathematical Cognition; Analog
Keywords:
κ4 : Q −→ f alse
κ2 : L −→ smaller
moveTowardsOrigin(V
Generalisation
1 ,V2 ,V3 , path)
Unification
κ
:
A
−→
align
3
(Arithmetic-2) τ : G(V
τ
:
A
−→
true
5
1 ,V2 ) −→
ρ11 :furtherFromOrigin(V
,V−→
κ4∀V
: 1Q
f alse 1 ,V,V
2 : bigger(V
2 ) → smaller(V2 ,V1 )
aaaa
τ6 : S −→
closestToOrigin of the Arithmetic Me
Formalization
1 2 , Path)
∀V1,V
,V2),V−→
Generalisation τρ22: : L(V
3 : P(V1 ,V2 ,V3 ) → M(V3 ,V2 ,V1 )
Abstract
τ7 : Q(V
origin(V1 , path)
1 ) −→
1 2
Object
Collection
,V2 , Path)
ρ3 :closerToOrigin(V
∀V1 ,V2 ,V3 ,V4 Abstract
:1(align(V
) ∧ P(VConstruction
(Arithmetic-1)
1 ,V2Object
2 ,V3 ,V4 )) → bigger(V4 ,V1 )
Object Collection
Motion
Along
A
Path
Object
Construction
to be filled . . .
τρ34: : P(V
∀V1 ,V2 ,V
: S(V
3 ) −→
1 ) → ¬bigger(V1 ,V2 )
MotionAntiAlong A Path
Keywords: Mathematical Cognition; Analogies;
to be filledmoveAwayFromOrigin(V
...
1 ,V2 ,V3 , Path)
Unification
α
:
∀C
,C
:
bigger(C
,C
)
β
:
∀
O
,
O
:
bigger(O
,
O
)
γ
:
∀
P
,
P
:
1
1
2
1
2
1
1
2
1
2
1
1
2
µ1 : P −→Keywords:
putTogether
λ1 :Analogies;
P −→ combine
Antiτ4,C: )M(VMathematical
1 ,V2 ,V3 ) −→ Cognition;
→ smaller(C
→ smaller(O2 , O1 )
2 moveTowardsOrigin(V
1
1 , P2 , path)
κfurtherFromOrigin(P
Unification
, Path)
1 : G −→ bigger
1 ,V2 ,V3λ
µ2 : M −→
takeAway
→
closerToOrigin(P2 , P1 , path)
2 : M −→ split
α2 : ∀C1 ,C2 ,C3 : putTogether(C1 ,C2 ,C3 )
β2 : ∀ O
, O2 , O3 : combine(O
, O2 , O
)
1
1
3
Formalization
of
the
Arithmetic
Metaphors
κ : L −→ smaller
τ5 :,CA ,C
−→)true
µ3 :→S takeAway(C
−→ smallestCollection
λ3 →
: Ssplit(O
−→ smallestW
γ2 : 2∀ P1 , P2 , P3 :
3 , O2 , O1 )holeOb ject
σ13 : 2∀V11,V
G(Vthe
→ L(V
)Object
2 : of
1 ,V2 )Arithmetic
2 ,V1Construction
Object
ObjectCollection
Collection
Object
Object
Construction
Motion
Motion
Along
AAPath
Path
Formalization
Metaphors
κmoveAwayFrom(P
: A −→
align 1 , P2 , P3 , path)
Collection
τ
:
S
−→
closestToOrigin
3Along
6
α3 : ∀C1 ,C2 ,C3 ,C
β3M(V
: ∀O
O2 ,)O3 , O4 :
4:: ∀V ,V ,V : P(V ,V ,V ) →
1 , ,V
σ
,V
→
moveTowardsOrigin(P
2
1
2
3
1
2
3
3
2
1
3 , P2 , P1 , path)
Object
Construction
κ4 : Q −→ false
Object
Q(V1 ) −→ origin(V
Path)
(align(C
(align(O1 , O2 ) ∧ combine(O2 , O3 , O4 ))
1 ,CCollection
2τ)7∧: putTogether(C
2 ,C3 ,C14,))
σ
:
∀V
,V
,V
,V
:
(A(V
,V
)
∧
P(V
,V
,V
))
→
G(V
,V
)
→
bigger(C
,C
)
→
bigger(O
,
O
)
γ
:
∀
P
,
P
,
P
:
3
1
2
3
4
1
2
2
3
4
4
1
Motion
Along
A
Path
αα
:
:
∀C
∀C
,C
,C
:
bigger(C
:
bigger(C
,C
,C
)
)
β
β
:
:
∀
∀
O
O
,
O
,
O
:
bigger(O
:
bigger(O
,
O
,
O
)
)
γ
γ
:
:
∀
∀
P
P
,
P
,
,
Path
Path
:
:
4
1
4
1
3
1
2
3
Object
Construction
11
11 22
1 22
11
11 22
1 22
11
11 22
moveAwayFromOrigin(P
→
→4smaller(C
smaller(O
smaller(O
,smallestWholeObject(O
O
furtherFromOrigin(P
furtherFromOrigin(P
, 2P,2Path)
, Path)
1 , P2 , P3 , path)
22,C
2:,C
1 )1σ)Along
1 )1 )
1 ,1P
)β→
→
,V222,2))
α
:smaller(C
∀C1 ,C
smallestCollection(C
∀ O11, O
:O
4 : ∀V1A,VPath
2 : S(V1 1) )→ (¬Q(V2→
Motion
4 : ¬G(V
1)
→ furtherFromOrigin(P
→
→
closerToOrigin(P
closerToOrigin(P
, 1P,1Path)
, Path)
3 , P1 , path)
2 ,2P
→
¬bigger(C
,C
)
→
¬bigger(O
,
O
)
αα
:
:
∀C
∀C
,C
,C
,C
,C
:
putTogether(C
:
putTogether(C
,C
,C
,C
,C
)
)
β
β
:
:
∀
∀
O
O
,
O
,
O
,
O
,
O
:
combine(O
:
combine(O
,
O
,
O
,
O
,
O
)
)
1
2
1
2
22
11 22 33
11 22 33
22
11 22 33
11 22 33
closestToOrigin(P
→→takeAway(C
takeAway(C
→→split(O
split(O
,O
,O
γ2γ2: :γ∀4∀P:1P,1∀P, 2P,12P, 3P,23Path
,:Path
::
1)
3 ,C
3 ,C
2 ,C
2 ,C
1 )1 )
3 ,3O
2 ,2O
1 )1 )
→ (¬origin(P12,1,P,path)
→
moveAwayFrom(P
moveAwayFrom(P
, 3P,3Path)
, Path)
2P,2P
κ
:
G
−→
bigger
1
αα
:
:
∀C
∀C
,C
,C
,C
,C
,C
,C
:
:
β
β
:
:
∀
∀
O
O
,
O
,
O
,
O
,
O
,
O
,
O
:
:
33
11 22 33 44
33
11 22 33 44
¬furtherFromOrigin(P
P
→→moveTowardsOrigin(P
moveTowardsOrigin(P
, 2P,2P, 3P
, Path)
1,3,Path)
2 , path))
1 ,1P
(align(C
(align(C
) ∧putTogether(C
(align(O
(align(O
,O
) ∧combine(O
combine(O
,O
,O
1 ,C
1 ,C
2 )2 ∧
2 ,C
2 ,C
3 ,C
3 ,C
4 ))
4 ))
1 ,1O
2 )2 ∧
2 ,2O
3 ,3O
4 ))
4 ))
κputTogether(C
2 : L −→ smaller
γ
:
∀
P
,
Origin
:
→→bigger(C
bigger(C
,C
,C
)
)
→
→
bigger(O
bigger(O
,
O
,
O
)
)
γ
γ
:
:
∀
∀
P
P
,
P
,
,
P
P
,
P
,
P
,
Path
,
Path
:
:
4 4 1 1 τ1 : G(V1 ,V2 ) −→
44 11
3 3 5 1 1 2 12 3 3 4 4
κ3 : furtherFromOrigin(V
A −→ align
moveTowardsOrigin(P
, ,P
, ,Origin,
moveAwayFromOrigin(P
moveAwayFromOrigin(P
, Path)path)
1, 3P
1, 4P
2 ,2P
3P
4Path)
1 ,Vβ24β, 4Path)
αα
∀C
: smallestCollection(C
: :∀∀OO
,O
: smallestWholeObject(O
4 4: :∀C
1 ,C
1 ,C
2 2: smallestCollection(C
1 )1 )
1 ,1O
2 2: smallestWholeObject(O
1 )1 )
→ origin(Origin, path)
→→furtherFromOrigin(P
furtherFromOrigin(P
, 1P,1Path)
, Path)
κτ)4):: Q
−→
false
4 ,4P
→→¬bigger(C
¬bigger(C
,C
,C
→
→
¬bigger(O
¬bigger(O
,
O
,
O
)
)
1 1 2 22 L(V1 ,V2 ) −→
11 22
γ4γ4: :∀∀P1P,1P, 2P,2Path
, Path: closestToOrigin(P
: closestToOrigin(P
closerToOrigin(V1 ,V2 , Path)
1 )1 )
→→(¬origin(P
(¬origin(P
, Path)→→
2 ,2Path)
τ3 : P(V1 ,V2 ,V3 ) −→
¬furtherFromOrigin(P
¬furtherFromOrigin(P
, 2P,2Path))
, Path))
1 ,1P
moveAwayFromOrigin(V1 ,V2 ,V3 , Path)
γ5γ5: :∀∀P1P,1and
Origin,
, Origin,
Path
Path: Along
:
Figure 2:τ Developing
Arithmetic
from
Object
Collection
,
Object
Construction
Motion
a
Path
,V2 ,Vsmaller(V
4 : M(V
3 ) −→ 2 ,V1 )
ρ1 : ∀V1 ,V2 : bigger(V
1 ,V12 ) →
moveTowardsOrigin(P
moveTowardsOrigin(P
, 1P,1Origin,
, Origin,Path)
Path)
1 ,1P
moveTowardsOrigin(V1 ,V2 ,V3 , Path)
→→origin(Origin,
origin(Origin,Path)
Path)
ρ2 : ∀V1 ,V2 ,V3 : P(V1 ,V2 ,V3 ) → M(V3 ,V2 ,V1 )
τ5 : A −→ true
ρ3 : metaphors.
∀V1 ,V2 ,V3 ,VThe
) ∧ P(V2 ,V3 ,V4of
)) the
→ bigger(V
4 : (align(V
1 ,V2descriptions
4 ,V1 ) Generalising two domains
grounding
original
domains
τ6 : S −→ closestToOrigin
ρ
:
∀V
,V
:
S(V
)
→
¬bigger(V
,V
)
2
1
2 to stay as closely to
are only4 given1 informally,
but
we 1tried
We tested various alternative formalisations, which all resulted
τ7 : Q(V
1 ) −→ origin(V1 , Path)

Unification

original as possible. One possible axiomatisation in H D T P
ρ1ρ1: :∀V
∀V
: bigger(V
,V
→smaller(V
smaller(V
,V
)
1 ,V
2Collection
1 ,V
2 )2 )→
2 ,V
1 )1Table
1 ,V
2: bigger(V
1domain
2in
of the
Object
is given
4. Such a forρ2ρ2: :∀V
,V
,V
: P(V
,V
,V
)3 )→→M(V
,V
,V
)1 )
∀V
,V
,V
:
P(V
,V
,V
M(V
,V
,V
1
2
3
1
2
3
3
2
1
1
2
3
1
2
3
2
malisation specifies the vocabulary that is used in the form of
ρ3ρ3: :σ∀V
∀V,V,V
,V
,V
∧,VP(V
bigger(V4 ,V1 )
2 ,V
3 ,V
2and
32,V
4: : (align(V
2 )2then
2 ,V3 ,V4 )) →
:4 G(V
L(V
1 :1 1∀V
1 ,V
1 ,V2 ) →1and
1 ) provides
sorts,
entities
predicates
facts
and laws
)∧
P(V
:¬bigger(V
G
−→
3 ,V
4 )) bigger
12 ,V
ρ4(align(V
:σ2∀V
,V121,V
: 2S(V
):κ
→
,V2M(V
) 3 ,V2 ,V1 )
1
1
1
:
∀V
,V
,V
P(V
,V
,V
)
→
2
3
1
2
3
to describe
the structure
the
domain.
For
example,
axiom
→ bigger(V
4 ,V1 ) κ : of
2 L −→ smaller
σ3 that
:1 ,V
∀V
,V
: (A(V1 ,V12C
)∧
P(V
G(V
2 ,V
4¬bigger(V
2 ,V
32,V
4 )) →
4 ,V1 ) i.e.
: ,V
S(V
,V
)
α3 ρstates
two
collections
and
C
can
be
aligned,
4 : ∀V
2 1if
1 )3→
2
1
κ3 : A −→ align
→ (¬Q(V2 )and
→ ¬G(V1 ,V2 ))
4 : ∀V1 ,V
2 : S(V
all theirσobjects
can
beκ14)paired
: Q −→up,
false C4 is created by putting
C2 and C
then C4 will be bigger than C1 . Note that
λ13: together,
P −→ combine
σ1 : ∀V1 ,V2 : G(V1 ,V2 ) → L(V2 ,V1 )
λformulae
split to be added to get a complete axiomafurther
2 : M −→ need
∀V,V
,V2: ,V
: P(V
) ,V
→ M(V
)
2 :∀V
3smallestWholeObject
1 ,V2 ,V3can
2 ,V1introduced
σσ
G(V
) 3 ,Vbe
:1 1S such
tisation,
formulae
into the
1: λ
2−→
1 ,V2 ) → L(V
2 1easily
3but
σ
:
∀V
,V
,V
,V
:
(A(V
,V
)
∧
P(V
,V
,V
))
1 ,V
2 ,V3:2P(V
4 ,V ,V
1 2
2,V 3,V 4) → G(V4 ,V1 )
G(V
) −→
1 :1long
σ2 3: τas
∀V
,V
system
constraints are
2 1as
3 some
1 elementary
2 3 ) → M(V3consistency
2 1
furtherFromOrigin(V
,→
path)
1 ,V
→ (¬Q(V
¬G(V
4 : ∀V
1 ,V2 : S(V1:)(A(V
2 )2P(V
1 ,V
σσ
))2 ))
→
G(V
satisfied.
adding
more
this
formalisation
3 : ∀VWhile
1 ,V2 ,V3 ,V
4
1 ,V2 ) ∧formulae
2 ,V3 ,V4to
4 ,V1 )
τ2 : L(V1 ,V2 ) −→
σ
:
∀V
,V
:
S(V
)
→
(¬Q(V
)
→
¬G(V
,V
))
might
the
support
for a specific
4 strengthen
1closerToOrigin(V
2
1
1 2 alignment, it does
1 ,V2 ,2 path)
not necessarily
introduce
τ3 : P(V1 ,V
2 ,V3 ) −→ new mappings of concepts to other
moveAwayFromOrigin(V
,V2α,V63,, which
path) states the transidomains. An
example for this1is
:τ4G(V
−→
1 ,V21),V
: M(V
2 ,V3 ) −→
tivityτ1of
bigger.
This
formula
embeds
bigger further in the
furtherFromOrigin(V
1 ,V2 ,1Path)
moveTowardsOrigin(V
,V2 ,V3 , path)
τ1 : G(V
1 ,V
2 ) −→
structure
of
the
domain
but
does
not
introduce
new concepts.
τ2 furtherFromOrigin(V
:τ5L(V
2 ) −→
: A1 ,V
−→
true
1 ,V2 , Path)
closerToOrigin(V
,
Path)
putTogether,
takeAway,1 ,V
bigger
and
smaller
are
considered
core
2
closestToOrigin
τ2 : τL(V
,V−→
6 : 1S
2 ) −→
τ3 closerToOrigin(V
: P(V
,V
,V
)
−→
concepts
of 1the
Object
Collection
domain.
In
what
follows,
we
2 3
1 ,V2 , Path)
τmoveAwayFromOrigin(V
path)
7 : Q(V1 ) −→ origin(V
11,,V
, Path)
2 ,V3to
willτ3restrict
our
axiomatisations
such
simple
versions
in
: P(V1 ,V2 ,V3 ) −→
τ4 moveAwayFromOrigin(V
: M(V1 ,V2 ,V3 ) −→
,V
,V
,
Path)
which
just
the
cores
of
the
domains
are
represented
and
conmoveTowardsOrigin(V11,V22,V33, Path)
τ4 : M(V
) −→ Furthermore, we will omit technical
nected
each
1 ,V2 ,Vother.
τ5 moveTowardsOrigin(V
: to
A −→
true3
1 ,V2 ,V3 , Path)
details
as
well
as
the
specification
of sorts and signatures for a
closestToOrigin
:−→
Gtrue
−→
bigger
τ5τ6: :κ
A1S−→
moreτ7concise
presentation.
: Q(V1 ) −→ origin(V1 , Path)
: LclosestToOrigin
−→ smaller
τ6 : κ
S2−→
−→ origin(V
align 1 , Path)
3 : 1A
τ7 : κ
Q(V
) −→
κ4 : Q −→ false
κ1 : G −→ bigger
−→bigger
smaller
κ1κ2: :GL−→
κ
:
A
−→
align
3
κ2 : L −→ smaller
κ
:
Q
−→
false
4
κ : A −→ align
3

κ4 : Q −→ false

in HDTP being able to establish appropriate analogies. Here
we present axiomatisations of the grounded domains that are
compact and consistent and that import integral parts of the
domains. Furthermore, we demonstrate how the transfer of
knowledge from one domain to another one works, because
this is a hallmark of ‘interesting’ analogies.
In a first step, we generalise the domains of Object Collection and Object Construction. (We only use the basic version of
the Object Construction domain here, which largely resembles
Object Collection. This version is not sufficient to introduce the
concept of fractions.) The axiomatisation of the two domains
can be found in the two boxes in the bottom left of figure 2.
The grounded domains are restricted to the operations that in
arithmetic correspond to greater, less, addition and subtraction. The axioms αi and βi (for i
1; : : : ; 4 ) correspond to
each other and are generalised in the obvious way by introducing individual variables and variables for operations. For
example, the predicate putTogether of the Object Collection
domain is identified with combine of Object Construction and
generalised to a variable P. The substitutions µ1 and λ1 can be
used to reconstruct the original expressions. Note that aligning
corresponding clauses in formalisations is only done for the
convenience of the reader; H D T P does not rely on such an
ordering to find the best possible analogical mapping.

1995

2f

g

for refinement. It indicates that an elaborated version of ρ4
might be used to describe Arithmetic-1, namely

Table 4: Formalisation of the Object Collection domain

8

ρ04 : V1 ; V2 : S(V1 )

Sorts
coll
Entities
singleton : coll
Predicates
smallestCollection : coll
bigger : coll  coll
smaller : coll  coll
equal : coll  coll
putTogether : coll  coll  coll
takeAway : coll  coll  coll
Laws
α1 : 8 C1 : coll; C2 : coll :
bigger(C1 ; C2 ) ! smaller(C2 ; C1 )
α2 : 8 C1 : coll; C2 : coll; C3 : coll :
putTogether(C1 ; C2 ; C3 ) ! takeAway(C3 ; C2 ; C1 )
α3 : 8 C1 : coll; C2 : coll; C3 : coll; C4 : coll :
align(C1 ; C2 ) ^ putTogether(C2 ; C3 ; C4 ) ! bigger(C4 ; C1 )
α4 : 8 C1 : coll; C2 : coll :
smallestCollection(C1 ) ! not(bigger(C1 ; C2 ))
α5 : 8 C1 : coll; C2 : coll :
equal(C1 ; C2 ) ! (:bigger(C1 ; C2 ) ^:smaller(C1 ; C2 ))
α6 : 8 C1 : coll; C2 : coll; C3 : coll :
(bigger(C1 ; C2 ) ^ bigger(C2 ; C3 )) ! bigger(C1 ; C3 )

! :Q V ! :bigger V
(

( 2)

( 1 ; V2 ))

which mainly states that if V1 is the smallest number, then
either V2 is Z E R O or V1 is not bigger than V2 . This new predicate Q can also be used for the transfer of additional formulae,
e.g. γ5 can be introduced into Arithmetic-1 resulting in

8

ρ5 : V1 ; O : M (V1 ; V1 ; O)

!Q O

( )

basically saying V1 minus V1 equals Z E R O . Thereby, the basic
ideas on Z E R O are incorporated into Arithmetic-1 by refinement and transfer from the Motion Along a Path domain.

Goguen’s notion of concept blending

:::

Facts
α7 : smallestCollection(singleton)
:::

Refining the generalisation
The formulae computed above by generalising Object Collection and Object Construction serve as a first formalisation of
elementary arithmetic (labelled Arithmetic-1 in figure 2). The
variables introduced by anti-unification are regarded as entities and predicates of this new domain. Because the grounded
domains chosen were very similar, and in particular because
the grounded domains neither have the concept E M P T Y C O L L E C T I O N nor E M P T Y C O N S T R U C T I O N , the system computes only a subtheory of arithmetic that lacks a neutral element with respect to the operation P (representing A D D I T I O N ). A second step of creating analogical mappings is
needed to transfer the concept Z E R O from a differently structured domain into our Arithmetic-1. This is achieved by the
second generalisation between the formalisation of Motion
Along a Path and Arithmetic-1 resulting in Arithmetic-2 depicted in figure 2.
The formalisation we chose for Motion Along a Path is different from the other domains in that the predicates take an
extra argument, path, to indicate the path along which the motion occurs. As a consequence, higher-order anti-unification
is applied which leads to the slightly more complex substitutions τ1 to τ7 and κ1 to κ4 . As before, these substitutions
can be used to reconstruct the source and target domains from
the generalisation. A further point to note is that γ4 contains
an additional condition in comparison to ρ4 . This mismatch
is handled by introducing a generalised predicate Q, which
is mapped to false by κ4 and therefore can be neglected in
Arithmetic-1. However, this dummy predicate is used as a hint

Another important means to create new mathematical concepts is concept blending, in particular in the form presented
by Goguen (2006). His figure 3, reproduced below, gives
an overview. Each node in this graph corresponds to a conceptual space in the sense of Gärdenfors (2000), which,
roughly speaking, is a subset of the system’s knowledge.
The arrows preserve the inferential structure from space to
G?
??
space, and the diagram commutes.

??


??

Goguen does not discuss exam
?



ples from arithmetic, but how from
I1 @
I2
@@
~
the concepts H O U S E and B O AT
~
@@
~~
@@
the concepts H O U S E B O AT and
~~
@  ~
~

B O AT H O U S E are created by conB
cept blending. The G space contains generic elements, such as
P E R S O N or O B J E C T ; the I spaces represent more specific
conceptual spaces, in his example I1 represents that a H O U S E
is on L A N D and that a P E R S O N L I V E S in it and I2 that
a PA S S E N G E R R I D E S in a B O AT and that the B O AT is
on WAT E R . Concept blending takes these conceptual spaces
and maps them into another space (the B space) in a way that,
for example, that the B O AT is mapped onto the P E R S O N
L I V I N G in a H O U S E , resulting in the concept of a house in
which the boat ‘lives’ – a B O AT H O U S E .
Fauconnier and Turner (2002, pp. 242–245) discuss blends
in arithmetic. Their presentation can be formulated in the form
suggested by Goguen (they are a major influence on Goguens
conception in the first place), thus giving an extension to the
work described in this paper. For example, Lakoff and Núñez’s
extended version of the motion along a path metaphor supports
an analogue of the rational numbers. Taking this as I2 and
object collection as I1 , a generalisation G can be found as
above, which ignores the division operation of I2 . Forming
the blend B then allows the extra operation to be incorporated
into a conceptualisation which respects the generalisation. The
blend can be seen as an updated view of I1 :

1996

Once we have the blend, and reify it, we can adopt the
view that the previous conception of number was ‘miss-

Acknowledgments

ing’ several numbers that were ‘there’ but not yet ‘discovered’. (Fauconnier & Turner, 2002, p. 244)

The research reported here was supported by E P S R C grant
EP/F035594/1 for the Wheelbarrow project.

Conclusions and future work

References

We examined to which extent the cognitive processes underlying mathematical thinking can be made formally precise and
algorithmically operationalised. For this purpose we took the
mathematical metaphors of Lakoff and Núñez (2000) and used
the analogy engine H D T P to compute generalisations from
the basic source domains of arithmetic based on higher-order
anti-unification.
For this, we used formalisations similar to the ones in our
earlier approaches using Information Flow theory and created
a first generalisation that contained the fundamental concepts
of arithmetic. We extended the first generalisation produced
by H D T P by incorporating a transfer of concepts, which
added new concepts to the ‘growing’ domain of arithmetic (in
our case the idea of a neutral element). Thus, anti-unification
cannot only serve to find abstractions of two source domains
but also to transfer concepts.
We also briefly described, how Goguen’s concept blending
is a direct extension of the HDTP approach. A paper detailing
the role of concept blending for arithmetic and a treatment
within the H D T P framework is currently submitted.
The demonstrated generalisation examples are still quite
simple. Enriching the domains to get more interesting transfer
candidates is therefore the next step. This notion of ‘interestingness’ is central to a comprehensive treatment of mathematical discovery, because there is an unlimited number of possible
theorems and theories, but only a fraction of these are deemed
interesting and useful enough for mathematicians to consider.
For automated theorem provers, this is a hard problem; one
on which we expect the heuristic nature of the HDTP engine
will shed more light.
The grounded domains as we used them here are already
generalisations of concrete situations, e.g. for the object collection domain the person/system must already have abstracted
over concrete instances of the acts of putting collections together and realised that this is a general law holding in this
domain. H D T P should be suited to create these abstractions
as well. A more pressing and fundamental case seems to be,
however, to create an abstract, generalised number concept
that extends beyond the subitising range, i.e. those cardinalities (ranging from one to three or four) for which humans
don’t need to count but immediately perceive the number of
objects and which seem to be innate.
Some other directions in which to extend our work are: (1)
How are the results influenced by the order of generalisation?
(2) How can the object construction domain be extended such
that fractions (rational numbers) can be introduced into the
domain of arithmetic? (This is Lakoff and Núñez’s fraction
extension of the basic metaphor.) (3) How can our approach
be extended to include Lakoff and Núñez’s linking metaphors,
which are used for creating more abstract mathematical concepts.

Barwise, J., & Seligman, J.(1997). Information flow: The logic
of distributed systems. Cambridge: Cambridge University
Press.
Fauconnier, G., & Turner, M. (2002). The way we think:
Conceptual blending and the mind’s hidden complexities.
New York: Basic Books.
Gärdenfors, P. (2000). Conceptual spaces: The geometry of
thought. Cambridge, MA: M I T Press.
Gentner, D. (1983). Structure-mapping: A theoretical framework for analogy. Cognitive Science, 7(2), 155–170.
Gentner, D., Bowdle, B. F., Wolff, P., & Boronat, C. (2001).
Metaphor is like analogy. In D. Gentner, K. J. Holyoak, &
B. N. Kokinov (Eds.), The analogical mind: Perspectives
from cognitive science (p. 199-253). Cambridge, MA: MIT
Press.
Gentner, D., & Markman, A. B. (1997). Structure mapping
in analogy and similarity. American Psychologist, 52(1),
45–56.
Goguen, J. (2006). Mathematical models of cognitive space
and time. In D. Andler, Y. Ogawa, M. Okada, & S.Watanabe
(Eds.), Reasoning and Cognition: Proceedings of the Interdisciplinary Conference on Reasoning and Cognition (pp.
125–128). Keio University Press.
Guhe, M., Pease, A., & Smaill, A. (2009). A cognitive model
of discovering commutativity. In Proceedings of the 31st
Annual Conference of the Cognitive Science Society. Austin,
TX: Cognitive Science Society.
Guhe, M., Smaill, A., & Pease, A. (2009a). A formal cognitive model of mathematical metaphors. In B. Mertsching,
M. Hund, & Z. Aziz (Eds.), KI 2009: Advances in Artificial
Intelligence (pp. 323–330). Berlin: Springer.
Guhe, M., Smaill, A., & Pease, A. (2009b). Using Information Flow for modelling mathematical metaphors. In Proceedings of the 9th International Conference on Cognitive
Modeling.
Krumnack, U., Schwering, A., Gust, H., & Kühnberger, K.-U.
(2007). Restricted higher-order anti-unification for analogy
making. In AI 2007: Advances in Artificial Intelligence (pp.
273–282). Berlin: Springer.
Lakatos, I. (1976). Proofs and refutations: The logic of mathematical discovery. Cambridge: Cambridge University Press.
Lakoff, G., & Núñez, R. E. (2000). Where mathematics comes
from: How the embodied mind brings mathematics into
being. New York: Basic Books.
Plotkin, G. D. (1970). A note on inductive generalization.
Machine Intelligence, 5, 153–163.
Schwering, A., Krumnack, U., Kühnberger, K.-U., & Gust,
H. (2009). Syntactic principles of Heuristic-Driven Theory
Projection. Journal of Cognitive Systems Research, 10(3),
251–269.

1997

